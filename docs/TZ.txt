###############
# Уже сделано #
###############

0. Консольное приложение
    На вход подаются слова, разделенные пробелом в виде предложения.
    Специальные символы удаляются.

1. Кадое слово представляется в виде понятия.
    Если слово ранее не употреблялось, для него создается .json файл, имя которого
    совпадаетс с самим понятием. Внутри может быть либо ссылка на файл .py, либо
    определение из других понтятий.

2. Выполнение программ.
    Слова в предложении последовательно выполняются в виде отдельной программы
    (процесса). Этому процессу передаются остальные слова в предложении в виде
    параметров. Так же доступен результат выполнения предыдущих слов в данном 
    предложении в файле output.json.

3. Отображение графа.
    Все слова в предложении делятся на пары, образуюя связи в графе.
    Граф записывается в файл local_graph.json виде списка связей. При выполнении 
    слов может быть дозапись в граф. Граф из json конвертируется в формать xdot
    и отображется.

####################
# Принятые решения #
####################

1. Не использую формат xdot или graphviz для хранения графа.
    Потому что были сложности с представлением подграфа в графе.
    В частности нельзя менять форму рамки подграфа, она всегда прямоугольная.
    В конце концов, это не редактор для рисования, а средство отображения только 
    графов. Храню граф в собственном формате, для подключения любых дргуих средств 
    рисования. Храню в фале json для просмотра после выполнения программы.
    Думал еще файлы .py как то макировать на картинке.

2. Не использую отдельные режимы вопроса или ответа.
    Любое выражение без явного упоминания знака вопроса можно расценить как вопрос
    и как ответ. Предлагаю знак вопроса парсить как отдельное слово, подразумевающее
    что должен быть дан обязательный ответ. Тесты с вопросами и ответами 
    обязательно будут. 
    Когда люди рассказывают историю они не просят выполнять код.
    Они используют код внутри себя для сохранения и моделирования. И не просят
    собеседника об этом принудительно.

3. Рекурсивное проваливание отсутсвует.
    Проваливание идет только по запросу. Одно и тоже слово может исполняться, а
    может использоваться как параметр. Если использовать сложные высокоуровневые
    слова, то проваливание может быть очень долгим или не закончиться вовсе.

4. Принятое определение это список слов с глубиной проваливания
    не дальче, чем 1.

5. Отказался от использования класса.
    В файле удобней смотреть промежуточные состояния. Допускаю
    использование класса как внутреннего формата для более
    быстрых расчетов между форматом хранения графа в файле и 
    выдачей ответа.

6. Отсутсвие имен и типов ребер.
    Вся информация и код содержится только в улах. У ребер учитывается только
    факт их наличия.

7. Не использую режимы работы или ключевые слова.
    Этот функционал все равно придется переносить в слова.

###############################################
# Краткосрочная перспектива (день разработки) #
###############################################

-1. Редми перевести на формат rst. Еще раз посмотреть разницу форматов md и rst.
    По прошлому анализу rst предпочтительней.

0. Изменить структуру файлов.
    У каждого понятия есть файл.
    Можно сделать его текстовым или среализуемым объектом.
    Текстовый не вариант, т к его придется мне самому парсить.
    Сереализуемый вариант, но он не человекочитаемый.
    Можно например json, он парсится автоматически, читаем и из него в коде делать объекты.

1. Переписать узел (вершину) на класс, а не только строка в графе.
    Нужно для хранения и исполнения кода внутри узла. Позже будет меньше кода в каждом узле, больше узлов.
    Написать функцию + руками для одного из объектов.

2. Операции над вершинами и связями.
    Изменение.
    Без деления на вопросы и ответы.
    Все в режиме впитывания в себя.

3. Добавить создание определения и названия знака из других знаков.
    Останавливаемся на определении двух видов
    1) Интенсиональное - состоит из болеее простых терминов.
    2) Экзистенциональное - выделяется на основе закономерности.
    Остановимся пока только на 1)
    https://ru.wikipedia.org/wiki/Определение_(логика)
    https://dic.academic.ru/dic.nsf/enc3p/220910

    Попробум дать определение одному из самых частотных слов - "год"
    год - это 365 дней.
    Доходим до секунда - еденица измерения времени.
    Опеделение единицы берется из математики.
    время - физическая характеристика
    измерение - использование органов чувств.

    Отталкнемся от органов чувств.
    Введем возможность узнавать время.

    Позже рассмотрим другие физические величины
    и доступные органы чувств.
    Дадим определение другим частотным словам.
    Наиболее рспространены части речи: предлоги, местоимения, существительные, прилагательные, глагол.
    Не работаем с толковым словарем для детей. Там много устаревших слов.
    Можно сделать фундоментальные понятия росовскими нодами.
    После определния времени дать определение "+"

    Работаем в двух режимах:
    Утверждение - создаем узлы.
    Вопрос - выполняем программы в них.

    Пока не добавляем БД, все храним в языке graphviz.

    Добавить квадратную рамку в ноду с именем .py
    .py выполняется как отдельная программа.
    Не импортом, не функцией, не переменной. Т к не все ноды содержат код.
    И нужных подпонятий в классе нет.
    Вынести функцию выполнения в класс.
    Зафисимость межу нодами, в том числе дача определений находятся в общем графе.

    Не выделяем режим дачи определения.
    Режим добавления узлов то же режим дачи определения.

    ???
    типа бывает обращение "дай определение"
    или что вопрос, что обращение, выполнение какого-то кода и по суди все сводится к одному режиму - выполни код

    После реализации нескольких определений с использованием python,
    создать определение второго уровня без использования python.

    Не создаем подграфы. 
    В graphviz одно пространство имен.
    Будет дублирование понятий в подграфах, если они там в зависимостях.
    Нельзя провести стрелку от субграфа к субграфу.
    Субграфы только прямоугольной формы.

    У фундоментальных понятий есть выходные параметры,
    в которых передается измеренные величины.
    У понятий второго уровня есть входные параметы,
    отражающие необходимость выполнения программы в них или дачи определения
    или подтверждения корректности определения.
    По реверт линку возвращается результат.

    Следующую физ характеристику добавить координату.
    Поработать с предложениями типа
    колобок находится рядом с бабушкой (в одной точке)
    Колобок побежал
    Колобок находится рядом с домом (в другой точке)
    Бежать - изменять свою координату

    сущществительное : обладает набором характеристик геометрические, поведенческие
    геометрия - тоже программа - набор констант

    Во время дачи ответа начинается рекурсивное проваливание до питоноского кода.
    Ответ собирается обратно в том узле с которого все начилось.
    По сути вопрос можно сформулировать как дай определение этого слова.
    Удтверждения - человек дает определение.
    Это описание вопроса - утверждения со стороны человека.
    Добавить описание в коде со стороны программы
    вопрос - человек дает определение
    утверждение человеку дают определение (иполнение кода в программе)
    зарисовка к вопросам
    Понять когда программе выгодно задавать вопросы.

    Сценарий отработки:
    время выведи капсом

    в глобальном графе элементы связываются друг с другом по приципу 
    входят в определение, 
    так же согласно истории если она есть
    или введенного предложения, утверждения

    В работе над определениями можно работать снизу вверх и сверху вниз.
    Снизу в верх это начала все первородные (датчики), потом второродные.
    Сверху вних - наоборот. Сначала шаблон опрнделения, потом проработка его
    отдельных составляющих.

    Дать определение секунды через пример. То есть вычитание конеретных двух меток вренени,
    а не сразу запись разница в 1.

3.5 Изменить способ отрисовки в графе.
    Ноды, которые являются питоновскими программами отображать прямоугольником.
    Список ссылок отображать в фигурных скобках в одной строке.
    Перенести честь метода отображения в класс.
    В main только сшивка в общий файл.  
    https://graphviz.org/doc/info/shapes.html
    https://stackoverflow.com/questions/2012036/graphviz-how-to-connect-subgraphs
    Почитать про стандартные потки вывода.
    Понять какие потоки у меня есть с учетом подпрограмм.
    https://stackoverflow.com/questions/1996518/retrieving-the-output-of-subprocess-call
    В одном из ответов ниже более развернутый ответ.
    Почитать про события мышкой в xdot
    Пока нет необходимости в грфовой БД
    Связи в graphviz, часть логики в .py и main

    Добавить функции
    венрни ноду 
    верни связи с нодой
    верни список "поднод"

    Структура файла graphviz

    digraph G {
    { 
        node [shape=ellipse]
        a [label="node a"]
        b [label="node b"]
        c [label="node c"]
        d [label="node d"]
    }
    a -> {c d}
    b -> {c d}
    }

    Когда нажимаешь на ноду, она подсвечиватся со всеми связями
    это получется и интенсиональное определение и экзистенциональное

    Перечитать документацию на graphviz с атрибутами

3.7 Запись историй
    Создание списка из глобальных событий.
    Присвоение глобальным событиям меток времени.

4. Синонимы.


5. Зпись историй.
    Как будет храниться последовательность событий во времени.
    Если делать постоянную ссылку на понятие "дальше", будет кашка.
    Нужна структура данных (список).

6. Истинность и ложность высказываний, закономерностей, гипотиз.
    Пишется, после реализации датчиков.
    Закономерности и гипотезы будут добавлены существенно ниже (позже).
    Истинными помечаются узлы, если они сраваясь с другими участками графа совпадают.
    Желательно делать несколько сравнений, если есть записи в истории о прецендентах.
    Сравнили с определением в теории, сравнили с применениями, описаниями на практике.

7. Выделение локальной и глобальной памяти.
    Высказывания попадают в глобальную память, когда меняется контекст или они считаются истиными.
    Куски графа из глобальной памяти могут применятся к разным контекстам в локальной.
    Флаг истинности или ложности оставить как в глобальной памяти, так в локальной.
    Пока идет считывание одной порции информации (одного предложения), все помещается в локальную память. Добавляются новые связи и элементы.
    Добавление временной метки к элементам и связям в любой памяти. Неужели из за этого придется класс для связи делать?
    Ссылка на программу которя порадила элемент, в котором эта ссылка находится. 
    Как могут выглядеть разные виды контекста (удаленность от текущей временной ветки) - отдельная задача.
    Делим ли мы стрелки на типы? Пока не делим, т к нет необходимости.
    Хранение истории в глобальной памяти. Привязка событий ко времени. Как по контексту, так и методанные. Хранить источник данных (из знака или внешней среды). Способ вывода из старых знаний. Время придется хранить как в опретивке, так и в глобале.

8. Код для вопросов и ответов.
    Повествование - только операция чтения над памятью.
    Ответ на вопрос может быть повествованием, соответсвенно это тоже чтение памяти.
    Когда не ответа на вопрос в памяти, может включаться генерация новых знаний, но это отдельная задача.
    В током случае должно говоритья, что нет ответа.
    Составление полного списка всех возможных слов, обозначающих форму вопроса и ответа. (Кто, что, где, почему и т д.) Найти список у учебнике русского и других языков.
    Как выглядит связь с вопросом в предложении?
    После детектирования вопроса, должна быь операция чтения.
    Отличеие вопроса от невопроса - знак вопроса в конце (в начале). Позж распознавание по вопросным словам. Риторические вопросы. Понимание желение собеседника. Эмулирование его в памяти.
    Вопрос системы - желание пополнить граф (отсутствие информации в графе на заданные впросы человеком).
    Ответ определениия с рекурсией один рисуется в виде локального графа.

9. Выделение закономерностей
    Выделение закономерностей это операция над несколькими узлами.
    Сам код выделения закономерности тоже храниться в одном из узлов.
    Узлы из которых выделяют закономерности получены не важно как от органов восприятия.
    Эти же узлы могут быть как сигналами в сыром виде, так и словами (другими абстракциями).
    Оригинал: https://www.youtube.com/watch?v=ZtPNSuWwsnA канал GS RUS

10. Генерация новых знаний.
    Должна включаться каждый раз, когда нет ответа в памяти. По сути мы ее ограничиваем в выводе.
    Отработать на задаче непосредственного менеджера. Пример с генерацией новых знаний. Напрямую связи между элементами не определены, но можно спросить систему через элемент.
    Один из вариантов, что знания заключаются в новых связях. Так же можно выделить новые знания в новых элементах. Например выполнилась мини программа внутри одного узла, и т к ответ представляет из себя ни разу не использованное слово, то сделать под него новый узел и выдать его за ответ. С цифрами сложнее. Под каждую новую цифру нет необходимости создавать новый узел. Все они попадают под определение цифры. Можно создать локальный узел, для ответа, т к в оперативке он новый. Потом забыть или запонмить факт возможного решения.
    Проверить генерацию новых знаний на сказке о колобке. От кого еще может уйти колобок, помимо перечисленных вариантов. (ответ от кого угодно). А если в рот попросят прыгуть? (ответ - ни от кого не уйдет, кроме того, кто попросил в рот прыгнуть).
    Можно воспринять как факты, для выработки знаний. (колобок от бабушки ушел,     колобок от дедушки ушел, колобо от зайца ушел, колобок от лисы не ушел). Если выделяестся закономерность (колобок от всех уходит), то она должна как-то записываться (в виде правила)?
    Так же еще есть язык даталог. Есть ли необходимость заключения его внутри узла? Пока не вижу. Он хороший пример ограничеий (правил), которым нужно соответсвовать, чтоб сделать вывод, дать ответ. Правила могут быть записаны на графе или в вершинах?
    Отдельная задача, но в данной группе - выделение правила из закономерности и запись на графе. Можно сначала без графа. Умение обобщать. Дедукция и индукция. + еще несколько по методичке викентьевой. Почитать статью на википедии о наукометрии.
    Фишка знаний в том, чтобы генерировать новые знания по имеющимся правилам.
    Бесполезно переписывать все возможные комбинации входов и выходов.
    Колобок ушел от бабушки? Колобок - сущность, вершина. Бабушка - сщность вершина. Ушел - оператор? можем ли мы ноые занияния сгенерировать? Или это только повествование. Пересказ это оператор? (нет. Новых заний нет, если новые зания есть, это уже не пересказ). Если появляются новая информация - значит оператор. Если не появляется - пересказ, повествование. Занния можно генерировать не только на цифрах, но и судить от кого еще уйдет колобок.

11. Режим копирования с обратной связью

###################################
# предметные области для парсинга #
###################################

0. Топ частотных слов.
    Продолжить и дойти от секунды до года.

1. Для парсинга больших текстов сырой версией программы можно ввести фильтр нормальной формы слова.
    https://ru.stackoverflow.com/questions/781115/Как-получить-нормальную-форму-слова-в-файле

1. Пространство - время
    Понятие координата.
    Начинать хранение информации с помощью простых понятий, например что где н
    аходится (транспорт, геометрия, пространство, расстояние как ресурс). Теория 
    игр кстати вспоминается. Мироощущение у ребенка.

1. Сказка про колобка
    Поискать сказки для детей 3 лет (для самых маленьких).

2. Арифметика

3. Задача сколько яблок
    Во первых, уровни вложенности. Маша и Катя находятся в комнате. И у них есть яблоки. Сколько всего у них яблок вмсте.
    Сложение. У кати 3, у маши 2. Сколько всего. Дублируется с задачей по программированию.
    решение логических задач
4. Задача непосредственного менеджера

5. Учебник по программированию
   Обучение программированию, как предметной области.
   Перевод задач по программированию с ЕЯ на ЯП.
   Выделение тех структур данных, которые не только в программировании. Схематичный рисунок.
6. Учебник по русскому языку

8. Придумать свою историю.
    Заставить генерировать историю. Фантазия? Планирование? Целеполагание? Какие 4 графа у МФТИ? (событие, роль - это типы знаков)

####################################################
# Недельная перспектива (доделать в следующий раз) #
####################################################

добавить к знакам операции логики и или не

Отработать сценарий нового понятия

Вывод определения из простых слов

Во время подгрузки в оперативку, подгружаются ассоциации, но не все. 
Для возможного использования. В зависимости от глубины. 
Контекст между предложений

Юмор - резкие связи с контекстом. 
Попробовать написать программку, которая преследует цель, 
оперируя понятиями (желание пошутить)

Слова обозначающие движение, слова обозначающие препятствия. 
Словестное описание по виртуальной карте со своими законами.

Методы отображения и хранения в бд для класса.

конвертация сказки про колобка в граф

попытаться дать определение через уже имеющиеся слова

парсинг вхожной строки с помощью библиотек. 
Готовнось обойтись без библиотек. 
Похожие буквы, опечатки, учет информации из ненормальной формы слова.

Когда-то хотел начать с цифр и операциях над ними 
(это в отншении типа связи и кода , хранящегося в узле) 
(в то же время, код оперций должен быить не в узле, а на языковом уровне) 
(оператор + должен быть отдельным узлом)

Все таки попробовать позже парсинг колобка

синонимы. Это просто ссылка или отельное понятие, 
и у ссылки есть степень выраженности. 
Может быть только чать понятия синонимична. 
В током случае нужна операция сравнивания всего со всем.

#####################################################################################
# Долгосрочная перспектива (тезисы, которые надо реализовать, но не понятно еще     #
# как и когда)                                                                      #
#####################################################################################

абстрагирование - отражает в себе неполноу возможности восприятия от датчиков

Создание языка

Перевод с языка на язык

Создание нескольких агентов. Экспремент с изменением кода на другом агенте (жизнеспособность).

Функция и свойство.

Научить учиться

Юмор - резкие связи с контекстом

Слова обозначающие движение, слова обозначающие препятствия.

1 2 3 слово (цифры). Даём определение 3 за счёт 2.
 Продумать добавление 1 и связь с 2. Или перестройка определения.

причина-следствие

Начало учебника по программированию. Как текст для парсинга.

Что будет, если все будет связано со всем - 
все нормально в голове связано все что нужно и не умираем. 
С математической точи зрения все со всем и не будет связвано.

Риторические вопросы

7. Перерограммирование себя.

8. Знак и символ, сигнал и шум.
    Когда известно, что ищем, то сравниваем входную информацию с одним шаблоном.
    Если совпадение удачное, то это из категории шум переходит в сигнал, или знак.
    Сигналы усиливаются, шумы фильтруются.
    Тест. В локальную картину добавляется новая информация порциями. Сигнал и шум могут меняться местами.
    Знаком может быть жест, действие. У знака конкретный смысл, у символа не до конца определенный. 
    Знаки и/или символы могут быить связаны.
    Знак, сигнал, символ - это абстракции. Абстракция - мера нашей возможности воспринять. Знания выделюятся из сигнала путем абстрагирования.
    Ребенок сначала работает в режиме копирования с обратной связью.

9. Части речи
    Можно поле в классе завести. Код внутренней программы может отличаться у разных частей речи.

10. Конфабуляция
    Определение из вики - ложные воспоминания, 
    в которых факты, бывшие в действительности либо видоизменённые, 
    переносятся в иное (часто в ближайшее) время и могут сочетаться с абсолютно 
    вымышленными событиями.

11.  Степень выраженности
    Нашел на картинке в группе общая семнтика.
    Ни о чем не получится узнать все.
    Никакие две вещи не одинаковы.
    Вещи сущестуют в сетпенях.
    Все меняется.
    С изменением среды может измениться и поведение.
    Разные люди оценивают по разному.

12. Определение знака по обстановке, в которой он используется.
    Упражнение - придумать новый знак с новой программой
    Изменение смысла знака, при том что раньше другой смысл был
    (Плавная граница слова недвижимость)
    едениц измерения нет, но что то считается недвижимосью, что-то нет
    еще пример, слово нарцысизм, у него есть тоже степень сравнения

13. Создание новых не известных образов из известных графических . Фантазия

14. перейти на графовую БД
    найти алгоритмы поиска узлов в графе

15. узел определения слова определнение

16. Этимология слов.
    Можно догадываться о новом слове по схожести с остальными.
    Применять программпу предпологаемого развития.
    Конечный смысл слова может оказаться совсем другим, поэтому, это не точно.

17. Определение знака в виде текста. Для начала в виде списка знаков.
    Отказываемся от ассоциаций с графикой пока.
    Словосочетания.
    Лингвисты подсчитали, чтобы понимать текст из одного миллиона слов на 90%,
    достаточно знать 15063 слова.

18. Если есть повторяющаяся ситуация, ее можно пометить занком.
     Закон повторения занести в программу.
    Попробовать записать закон повторения не на питоне, а на знаках.

19. Целевые критерии
    Из них выводятся локальные цели.
    Записываются на языке существующих понятий.
    Возможно фундоментальных понятий.

20. Вывод определений без человека по окуржающей обстановке.

21. Запись зависимостей, через автомат
    Игра с детьми, кошками, попугаем.
    На 4 раз понимаем, что головой биться не надо.
    Граф из 4 состояний. Обращение к памяти.

################################
# Советы по организации мыслей #
################################

1. Оперировать понятиями, а не словами.

2.  Объяснение почему есть код в узле, хотя мы заявляем что должны обойтись без кода.
    
    2.1 Уже есть досаточно большой объем кода написанный людьми. Было бы глупо его не использовать.
        
        Вспомним арифметику. Знания о том как складывать числа уже имеются и зашиты в операторе плюс. Мы используем времмно это готовое решение на ЯП. Есть куча других языков, например грфический или нейросетевой, которые могут предоставить альтернативное решение для знака. В начале мы еще не знаем альтернативных методов и все они тоже должны будут быть записаны словесно.

        Даже если мы используем ЯП в определении. То выход этой минимпрограммы должен максимально использоваться в языковом уровне. То есть, связи до узлов, новые узлы.
    
    2.2 Понятие может быть программой. Можно ли избавиться от программ в понятиях? Как программы представлены в голове - нейронами. Один нейрон - не одно понятие. Даже сами понятия это небольшие сетки. Поэтому в каждом понятии в перспективе будет программа внутри или сетка. Важное отличие от всего, что хранится внутри - наличие названия (заголовка), как все это представлно в языке.
    
    2.3 Как должен выглядеть процесс написания программ внутри узлов. На ЯП, тут все понятно. На понятиях, должно использоваться минимальное количество кода. Понятие выглядит как последовательность узлов и связей между узлами, все это сохранено под одним адресом (заголовком). Да, в каждом узле может быть код. Но интерес в том, что при оперировании понятиями, чье определение состоит из других понятий - кода нет. Назовем оперироваие понятиями, в которых уже нет кода - верним уровнем или языковым. Да, программа определения знака это подграф в графе.

    Программа может писаться как на языковом уровне так и на языке программирования
    К написанию на чистом языке мы сейчас не готовы. На верхнем уровне вообще не будет ЯП.

3. Можно свести все к if-else.
    Соглашусь. Думаю все это сводится к коннекционизму. Можно вспомнить язык 
    даталог, на котором храняться ограничения и делаются логические выводы. Там 
    все к ифам сводится. У нас есть ифы, которые администрируют граф. От данного 
    подхода, откажемся, когда перейдем к верхнему уровню.

4. Сложные понятия
    Если сущность не имеет физических характерисиик. абстракция, вина, 
    обещание - нет это все программы и они все завязаны на физ характеристиках

#####################################
# Возможно используемые библиотетки #
#####################################

pymorphy2 - привод слова к нормальной форме
nltk - разбиение на предложения и слова (токенизация), удаление лишних слов, нормальная форма
rutermextract - выделение ключевых слов
PyMystem3 - еще привод к нормальной форме (лематизация), но надо по несколько предложений, чтоб быстро


#########
    Посмотреть можно ли дополнить тз этими свойсвтами
    https://en.wikipedia.org/wiki/Artificial_general_intelligence
    https://ru.wikipedia.org/wiki/Сильный_и_слабый_искусственные_интеллекты