редми перевести на формат rst

Добавить квадратную рамку в ноду с именем .py
закончить проверку считывания квадратной рамки

Код выполняется когда ствят знак вопроса.
Ответ выводится в консоль.
Если это .py то результат выполнения

Вывод определения 2 уровня
потренироваться на абстрактных цифрах 1,2,3,4
Создать функцию при задаче вопроса с рекурсивным проваливанием и выдаечей ответа
до самого нижнего уровня (это текущее определени) 
(программа сама себе задает вопрос в соответсвии с целевым критерием)
проваливание на один уровень - абстрактное определение

Вынести функцию выполнения файлов .py в класс.

Добавить понятие координата

Часть функции отрисовки вынести в класс с линками в виде {2, 3}

------------------
в отпуске
все что выше разобрать
читаю заметки
одно из последних решений перейти от формата xdot к формату json
главное, что кажое понятие это не часть файла xdot, а отдельный файл с определением внутри себя
выяснить почему я пришел к  этой мысле

освежил в памяти, прочитал заметки один раз
почему я принял решение выносить определение в отдельный файл - коротко сказать не могу
работа с xdot была удоба по началу.
Возможно пришло время его замены или дополнения
Так или иначе попробуем еще раз представить всю картину работы с определениями

1) На вход приложению через консольный ввод поступают слова
Это может быть одиночное слово, несколько слов разделенные пробелами
Для простоты ограничимся пока одним словом
2) Есть два вида представления понятий в памяти
Первый это объекты класса "node" на языке python
Второй это json файлы
json человекочитаемый
объектами python мы оперируем, изменяем, сравниваем и т д
json храним и проверяме то что создалось
3) есть фундоментальные понятия, они опрашивают драйвера
понтия второго рода состоят из ряда фундоментальных понятий
4) есть режимы работы
первый - человек говорит утверждение, программа его записывает
второй - человек просит дать определение понятия
причем для первичных и для вторичных понтий ответы будут разной формы
для первичных это вывод датчика, то есть отработка кода на python
для вторичных список ссылок на другие понятия
Работаем пока через консоль.
Переключаем резжмы или в коде или с помощью ключевыйх слов, чтоб не заниматься сейчас парсингом и контекстом
5) отрисовка в графе
есть функция превода из json в объекты и наоборот
есть функция отрисовки части загруженных объетов с помощью xdot
6) как представлены программы
есть папочка с файлами .py
в ней есть фалы, имена которых могут совпадать с именами в папке с jsonнами понятий
в json есть ссылки на файлы .py (для первичных определений)
7) как передаются параметры
Слова могут быть записаны через пробел
в таком случе слово слева и слово справа воспринимаются как ыходные параметры
если мы работаем в режиме утверждения, то они записываются в качестве определения
если мы работаем в режиме вопроса, то они идут на фход программе
с питоновскими программами все понятно
если это поределение второго рода,
 то рекурсивно вызываются определения из которых было напиано это определение второго рода
и уже им предаются параметры для вычислений
есть еще выходной параметр для завершения рекурсии
от слоя к слою в рекурсии разные параметры передаются, а не один и тот же
8) масштабируемость
сценарий добавления новорго определения
создать файл, записать название
если это первичное, то .py
если вторичное список определений
список берется из параметров
добавить понятия "скажи", "выведи", посчитай и т п, "дай определение", "удали"
Первые определния первого рода создать руками
Потом создать понятие опредения и его дачи ("даю определение ...")

Часть из вышеописанного выполнил
создает определение времени в json с связкой кода на python
выдает результат выполнения

Интерисует определение 
секунда - еденица измерения времени

дать определения всем трем словам

Есть два подхода в организации определений 2 рода.
Первый - дать поределение всем втророродным определениям входящим в его сострав, опускаясь до первородных.
Второй - взять одно первородное определение и развивать из него все второродные.

Рассмотрим сначала 2 вариант.

Опасения по поводу 2 варианта..
Мы играем в машину тьюринга. С ифамия так то смерился.
Как из этого сохранения вывести слово измерение и еденица.
при обрисовке ситуации с двумя временами и разницей между ними в 1, должен быть получен ответ - секунда
ситуация должна быть представлена одновременными событиями в виде графа
если это граф наложить на определение секунды, они должны совпасть
получается вывод команды время должен попадать в оперативку
в деталях: мы создаем файл в папке local_memory с типом данных json и менем id (счетчик)
внутр json показания, пометка времени

все вопросы и ответы записываются в оперативку

Начал рисовать граф в draw io с позиции как должно быть
подготовлю вопросы к нему еще раз в файле formulations.txt

вводятся понятия
два числа 1658921962 и 1658921963, в разных утверждениях
в этих же утверждениях присутствет слово время
поэтому образуется кусочек графа из этих трех узлов
у них нет определений
действительно, цифры получены от датчика, только датчик сейчас человек
время под вопросом, но для простоты эксперемента оставим его без определения
далее задаем вопрос: 1658921963 разница 1658921962
ответ должен быть: 1
разница заводится руками, содержит код на питоне вычитающий из числа слева число справа
это мы делаем подводку к определению секунды на примере
само определение секунды не обязательно должно содержать пример, 
а если и содержать то маркироваться вместе с узлом пример
Получается секунда это чатсть графа, одновременно включающая 3 понятия: 1 разница время
Это ее код не на питоне. Определение второго рода получается
Возникла мысль таки сделать направление стрелок
Оно должно показывать входной параметр или результат
результат нужно еще науиться ловить с субпроцесом
еще раз репетируем все вопросы и утвррджения глядя на граф
когда мы задаем вопрос, то выполняется код во всех словах, 
которые есть в вопросе.
Если в слове нет кода, оно пропускается
потом все ответы складываются в одну строку
Наблюдается два вида вопроса
один с кодом питона, другой с кодом на словах
когда я говорю утверждение я должен просить выполнить код?
вообще-то нет. Когда люди рассказывают историю они не просят выполнять код
они используют только код для сохранения и моделирования
Во всех 3 примерх утверждения 3 итерации в formulations 
утверждение это сохраниение в граф
каждый раз когда проиходит впорос, выполняеются коды во всех словах в узлах
Есть проблемные места
первое - вопрос: секунда
заходим в его код
там 3 слова 
у 1 должна из разницы высчитываться
если разницу выполнить она вообще из 1 время вычитать будет
время без кода ему без разницы
Чем выполнение слова разница отличается в двух вопросах
вопрос: 1658921963 разница 1658921962
вопрос: 1 разница время
если это разные поведения программы , корющиеся под оной и той же командой "вопрос:" или знак ?
тогда их надо разделить
предлагаю ввести ключевые вопросные слова
если они состоят их нескольких слов, то тогда через подчеркивание их пока писать
потом разделю
какие слова мне нужны, отражу в formulations итерация 4
по результато 4 итерации
любое обращеие, это выполнение кода
с направлением стрелок не разобрался и
не разместил в графе "мета узлы", 
посмотреть на сколько они мешаться будут и нужны ли вообще пока
их можно просто кодом оставить, потом в узлы вынести
После наброска 4 итерации
по идее, все должно быть в виде узлов и эти команды в том числе
их код выполняется (загружаются представления о них), но вывод никуда не отдается
можно сделать так
когда метаузлы выполняются, связи до них не протягивать?
нет уже, пока оставлю все связи
да, получатея кашка
нужно отрисовывать граф по разному
когда опрделение просят вывести, то только его
а не весь граф
----------------
останавливаемся тогда на этой модели
кодим
+ кодим отрисовку
учимся чисттить локальный граф
в глоальном все связи остаются? ДА
даже с мета узами, узлы ведь когда-то были добавлены как то
никто не заставляет все отрисовывать
ну и да, метаузел решает с кем и когда протягивать связи
например во фразе 
"сохрани_узлы время 1658921962"
не очевидно, что между сохрани_узлы и 1658921962
нужно делать связь, а она там должна быть
------------------
приехал в магнитку, кодю
первое утверждение
"сохрани_узлы время 1658921962"
первое слово ищется в списке джесонов и выполняется
оставшиеся слова воспринимаются как входные параметры
код первого слова выполнится, создадутся 2 узла
в принципе мы их тоже можем запустить, но в них нет кода

опять возникли опасения, что это похоже на ЯП
Да, это действительно так, но позже мы его существенно расширим и переопределим
дайте только денег)
поместить в соответсвующий раздел в тз

мне нужно после узла сохрани_узлы вернуть ответ, чтоб другие узлы не выполнялись!!!!

отлично
первую строчу по созданию узла сделал
не сделал проверку, если нода существует
не сделал отображение
не сделал разделение на локальный и глоб граф

зачем я ввел ключевые слова:
ЗА:
- любое предложение исполняется, не важно вопрос, ответ или дача определеня, запись определения. Ввод доп режима, которое не входит в состав предложения приведет к тому,
что придется позже код из режима переносить в слова (понятия)
- сценарии одного и того же слова могут быть различны в зависимости от окружающих слов (параметров). Больше параметров, гибче реакция.
ПРОТИВ:
- когда человеку говорят предложение, у него поднимается сразу весь код слова, ограниченный контекстом. (мы так не сможем)
Вывод определений не производится (рекурсивоное проваливание)
- 

еще раз порядок выполнения программы
выполняю все слова в строчке
нахожу первый json
в нем нахожу питон и 
передаю ему оставшиеся параметры
в питне принимаю решение как обрабатывать оставшиеся параметры
если среди параметров есть еще выполняемые слова
то выполняем их и передаем оставшиеся слова и т д

возникают частоиспользуемые функции
например найди программу по названию через все дсоны

нужно понять как результат выполнения наверх передавать
в нем должно содержаться в том числе, что некоторые слова , может и все, не нужно выполнять
потренироваться на сохрани узлы

походу субпроцесс параллельно запускает все слова на выполнение
надо в начале функции выполнения слов что-то придумывать

------

пусть запускаются все слова
внутри слов написать код, с какими соседями работать не надо
если вычисли с параметрами, то 3 и 4 параметр
пофилосовствовать, какие слова человек не стал бы обрабатывать и откуда берет инфу

Каждое слово должно заниматься своим делом
Решил
Код должен выполняться последовательно
Сначала помечаем параметры, потом передаем минусу
Обратная сторона - параллельное выполнение
Тогда каждое слово учитывает контекст и выполняет работу, которая дублируется в каждом слове в предложении
В этом есть и плюс - доп проверка в каждом слове
Записать этот подход в комментариях в коде
Еще о параллельном подходе
3 из 4 слов не должны будут вернуть результат
значит они бесполезно отработали, еще раз удостоверяюсь в правильности последовательного подхода


------

тут выясняется, что есть предложения, где порядок важен, а есть где не важен

например 
3 минус 2
и
2 минус 3 
принципиальная разница

а
машка вредина, отдай
или
вредина машка, отдай

без разницы

-----

можно конечно сейчас и сделать последовательно,
но потом придется переделывать

1658921963 разница 1658921962
придется вызывать первое слово,
в нем не будет кода
потом второе и в нем брать первый параметр из контекста
-------

подумать над отладкой субпроцессных файлов
разработать шаблон с ифнейммейном и меняющимися параметрами запуска в
 зависимости от каталога

------

листочке нарисовать пайплайн

-----

сейчас сохраняются ссылки только при сохранении узлов
а должны при любой реплике

второй вопрос, в какой файл они записываются
записываются в сохраняемое слово + добавляется сохрани узлы

сохрани узлы в первую очередь формирует json
выполни параметры отсутсвует в графе, потому что я его руками добавлял
в выполни параметры все равно отсутсвют ссылки на продолжающуюся строку

получается, перед выполнением любой строки мы пробигаемся по словам и добавляем 
ссылки все ко всем

где в таком случае будет разгроничение на глобальный граф и локальный
эти ссылки в json должны были использоваться такт то только для определения
от того что мы строим локальный граф нам не важно
может локальный грфаф в файл xdot сразу писать?
Нет, писать всю инфу удобней в json
нужно просто разжелить поля
link переименовать в local_graph
для секунды добавить defenition
последнюю строчку тем не мнее искать не по всем файлам с defenition
хотя он такой один у нас, а по наложению на граф

итак, итожу
link переименовать в local_graph
для секунды добавить defenition, помимо local_graph
local_graph заполняется в майне все слова со всеми
если слова нет, то тогда создается
получается убираем сохрани узлы (о ужас), нет оставляем там еще питон и 
сохранение результатов после выполнения, хотя о этом ндо тоже подумать

еще раз не к месту
от ключевых слов до конца не отказываюсь
отказываюсь от сохрани узлы, т к он в каждой строке и Так
в файле графа все равно не пишу, т к в json можно зайти посмотреть
и все что угодно дополнить

потом чтение операций над графами
поиск по джейсонам через джейсон не охота заниматься
файл графа все же остается и генерируется
его можно покрасивше сделать без дублей и 
сразу дописывать по ходу выполнения, а не пробегать по всем словам 
каждую итерацию

вохзник вопрос может вместо хранения в каждом файле local_graph
хранить это в файле графа
ответ - нет, тогда файл графа нельзя будет потерять
придется пробегаться по фалам, чтоб чистить это поле после диалога
где -то должен быть список всех задействованных слов
нужна автоматическая очистка при каждом запуске
тогда, да, придется переписываться в файл графа
помниться ты от этого уйти хотел
неужели нужно свой формат хранени графа
нет
просто я буду обрабатывать выход
мне все же удобно работать, и смотреть, что происходт с каждым понятием в файле
заведу список всех задействованных понятий
буду перед выходом чистить
по файлу графа можно пробежаться (лучше по списку)
если аварийное завершение, 
то при любом запуске придется пробегаться по всем ловам и чистить поля
параокс
либо удобство работы с фалом, либо централизованное хранение
по логике должно победить второе
значить не просто меняю link на local_graph
а перенашу запись в файл
делаю ее адекватоной
посмотреть как сейчас отрисовка происходит
тут походу не на 15 мин, на сегодня все

еще один переходник
можно же не сразу в граф писать, а в json
отказываюсь


-----
09,10,2022
я же хотел уйти от записи в .dot
потому что там есть ограничения на отрисовку
можно сделать промежуточный вариант хранения и подключить .dot за не имением альтернатив пока
скорей всего я опять скланюсь к json
только это не распихано по файлам, а в одном
обе цели выполняются: и централизация и незапись в .dot

-------
10 10 2022

при сохранении связей во входном предложении
отказываюсь делать связи все со всеми
мешанина получается, пробовал на графе иллюстрации
последовательно буду

-------
11 10 2022
все слова в предложении конвертируются в последовательные пары
после обработки возможно проведение новых слов
определения зписываются в json слова (в первую очереь), в локальный_граф.json тоже, но только для отрисовки
новые связи тоже могут появляться после обработки

-------
15 10 2022
во время сохранения определения
пробрасывать связи с определяемого слова на все слова учавствующие в определени
