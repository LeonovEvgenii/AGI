    Мысли в слух, потом подудаляю или распихаю по разделам
    Опять я программирую слово "=" на питоне. Запись производится в файл.
    Я искал универсальное хранилще для знака и понтяия и решил, что это будет файл.
    В файл можно записать любые аспекты.
    Идеальная ситуация, когда выделяются новые понятия.
    Эта ситуация возможна тогда, когда идет текст. Формируется граф.
    Появляются новые слова, они добавляются в граф. Дальше необходимо понять
    закономерность, какую они обозначают. Генерируется набор функций из известных
    элементов и выбирается наилучшая гипотеза.
    Еще вариант создания нового понятия - обозначение повторяющиеся последовательности слов
    от предложения к предложению.

    Каждый раз когда мы добавляем глагол - у него пишется алгоритм.
    А когда добавляем существительное - разве нет?
    Слово может все что угодно содержать, есть понятия, которые сложные вещи
    описывают и поэтому отсутсвие алгоритма не обязательное свойство существительного.

    Ничего страшного нет, что ты пишешь питоновский код в слово "=". Когда будешь
    решать задачки по программированию по сложнее, там будут определения второго рода.

    Еще примеры
    поиск макисмума сначала из 3 чисел
    потом из 5 (уже сортировка массива будет, потом выдача первого)
    потом максимальное четное (сначала сортировка, потом четное)

    Работа с бесконечностями
    точка закрашенная область, меньше которой закрасить нельзя
    подводка к определению бесконесно малый и бесконечно большой
    (точка и отрезок)

    Продолжаю рассуждать про переменные.
    Один из вариантов - перейти сразу к объяснению одномерного пространства.
    Подразумевалось, что ЯП будет объяснен на ЕЯ.
    Если объяснять сохранение многих значений во многих переменных, то все они будут
    иметь связи со словом "хранит".

    Если рассматривать перезапись одной и той же переменной (a = 1 a = 2 a = 3), то на текущий момент
    в графе показывается, a имеет связь со всеми тремя значениями и не отображает последнее хранящееся значение.
    Это из-за того, что не учитывается порядок ввода. Придется для каждого узла метку времени ыыодить.
    Не используемые значения выкидывать. В результате я играю в компилятор.

    Если использовать уже существующий шаблон, то нужно чтоб слово "=" протягивало связь от переменной к значению.

    В таком случае нужно перед каждой строкой говорить, что это переменная и в нее идет запись значения.
    Или еще лучше, что сейчас мы будм программировать.

    Получается из за контекста используются другие значения.

    Получается это вникание в синтаксис ЯП, а не алгоритмы.
    Чтобы объяснять алгоритмы на ЕЯ, нужны местоимения, лица и обозначение объектов над которыми
    можно производить операции.

    Резюмируем
    Для ЯП нужен контекст.
    А алгоритмы попробуем реализовать на словах, а не на операторах питона.

    Может Маша и яблоки?

    маша хранит одно яблоко
    даша хранит два яблоко
    сколько яблоко всего

    Вообще не очевидно что такое "один", "два", "всего".

    Может симулятор подключить и объекты расставлять.
    Маша один кубик, Даше еще один.
    Яблоки шарики. Можно про воксели вспомнить и про классификацию.
    Слово "всего" подсчет количества объектов одинакового класса?

    Что если самому попробовать составить граф определений топа 10 популярных слов

    Есть определения, которые отталкиваются от физических величин.
    Есть математические и философские определения. Можно сказать, что информационные.
    Математические наверняка когда-то были связаны с физическими и образовались из них.
    Если я хочу объяснить слово "четыре", значит мне придется в реальности показывать
    разные четверки объектв и говорить, что их что-то объединяет. А именно - количественность.
    Числа - отражения количественности величин.
    Переменные - псевданимы и обозначения величин. Присвоение имени.
    Так же есть классы и экземпляры.
    Экземпляры отличаются друг от друга только назвнием.
    Например - "яблоко" и "другое яблоко"
    Числа это тоже классы.
    У числа 4 могут быть экземпляры. 4 обозначющее яблоки и 4 обозначающее людей.
    4 обозначающий абстрактный шаблон.

    Получается к понятиям нужно добавить экземплярность.
    На все ли понятия накладывается экзмплярность или есть исключения.

    Работа с симулятором.

    Понятие кодируемое буквами это не только возможный питоновский код, но еще и 
    список объектов, веселей в симуляторе.

    Как эе быть с переменными?
    Сначала модель цифр сделать из реальности.
    ЯП по сути это калька с реальности для применения определенных подсчетов.
    Операторы - упращенная версия реальных действий , только с определенными свойствами.

    Может попробовать дать определение каким-нибудь глаголам.

    Резюме
    1) определение глаголов
    2) топ 10 граф
    3) рассужденния об экземплярности каждого понятия (например слово "год")
    4) введение определения одномерного пространства
    5) поиск симулятора

    Определение глагола.
    Например передвигаться - изменять свою координату.
    Это шаблон, который можно сравнить с уже совершенным или планируемым действием.
    (локальным графом). и сказать похож или не очень.

    Контексты и фантазии можно представить как записи локального графа в глобальный
    с пометкой когда он был сделан и при каких обстоятельствах.

    Практически любые определения упираются в подсчет объектов.
    Которые, я хотел бы объяснять в симуляторе.
    Допустим симулятор у меня уже есть. Как бы я это объяснял?

    Рисуем иллюстрацию

    1100100001000101

    сколько единиц?

    есть определение слова единица и это шаблон.
    Чтобы понять вопрос, должно быть жестко закадировано понятие шаблона.

    Зачем обязательно в грфику уходить, представляя одномерный массив 1100100001000101
    или многомерный в симуляторе.

    я так же могу в строку через пробел записать 1 1 0 0 1 0 0 0 0 1 0 0 0 1 0 1
    и спросить сколько единиц?

    Люди в отличие от животных научились мыслить абстрактно, а не только принимать показания с датчиков

    строка - это сырые показания.

    абстрация - это использование одних признаков и неиспользование дргугих.

    В ЯП происходит операция сложения в ячейку памяти и сравнение с шаблоном.

    Для любых других цифр - 2, 3, 4 и т д будут дургие шаблоны.
    Если бы я запустил эту строку на текущей реализации программы, то получил бы граф из двух элементов.
    То есть время создания узла в локальном графе - обязательный компонент.
    Может тогда и тип ввода изменить по словам.
    Предложения это тоже абстракии. Первоочередное - это одиночные знаки.

    Если человеку сказать эту же последовательность, он среди всего многообразия вываленных на него признаков
    подчеркнет именно количественность. Не важно считает он это на слух или пишет на бумаге.

    Свойство за которым я гоняюсь - это генерация шаблонов и их использование в любом типе сигнала.

    На каком языке будет записываться этот шаблон?
    Должен ли он использовать те же кирпичики из которых состоит сам сигнал с датчика.
    В живых орггнизмах язык вернего уровня тоже работает поверх ассемблера на генах.
    Нейросети подбирают функцию любой сложности к сигналу.
    Твой подход чем-то отличается от всех дргих попыток постройки интеллектуальных агентов?
    Все началось с отражения связи между словами в тексте.

    возьмем последовательность

    110001100011000 и т д

    Рассмотрим окно []
    запихаем сначала 1 символ из последовательности, пробежимся окном по последовательности
    вычислим ошибку
    потом двумя [11]
    потом тремя [110]
    [1100]
    до [11000]
    Если увеличить окно, то или ошибка перестанет расти
    или период повторения будет уменьшаться

    как подбирать сложные зависимости, когда следующий элемент вычисляется на основ епредыдущего

    нам ведь не надо предсказывать, хотя выделение шаблона, это по сути предсказания

    Тебе нужно было всего-то отпределение цифры на языке твоей проги.

    по сути даже на этой беспорядочной последвательнсти можно выделить шаблоны

    1 - 1
    11 -2
    111 -3
    и т д

    у знака есть id 
    знак задается через положительно подкрепление
    подкрепление, значт есть целевой критерий
    У живых оргнаизмо целевой критерий покормить или похвалить
    может цифры через покормить создавались

    создать симулятор с бегущей строкой, посмотреть как он выработает шаблоны цифр
    может от цифр будет недалеко и до букв и слов

    -----------------

    составил скриптик по поиску шаблона в строке
    цифра три - три единицы подряд
    усложним определение цифры три
    это элмемнт и элемент и элемент
    все элементы равны
    в определении йифры не должна участвовать сама цифра
    нужна какая-то оперативная память, где будут собираться шаблоны
    нужно воспроизвести генерацию шаблона

    в принципе есть надежда, на использование существующего софта
    только вместо единиц и нулей слова с обязатеьными метками времени.
    Метку времени походу придется сделать в файле описания слова, наряду
    с полями имя, определения, питоновский файл.

    1) рандомная генерация строки длинной 1000 скажем
    2) интерисуемся пока шаблонами только из единиц, хотя други тоже возможны
    но мне пока не нужны
    3) берем шаблон "1" и бежим по строке собирая индексы
    4) увеличиваем длинну шаблона на еще +1, повторяем вывод
    чисто теоретически мы найдем все вхождения
    можно даже переписать строку заменив найденные шаблоны на арабские цифры.

    меня смущает, что в написанном коде будут знаки +
    когд, который пишется, это симуляция высокоуровневой деятельности
    если бы было на мозгу человека, то он бы в оперативное поле или фантазию
    помещал два фрагмента и искал сходство

    Ребенок без труда замечает, что два каких-то предмета могут быть одинаковыми

    Потом он может зметить что удобно помечать определенное количество знаком
    и обмениваться инфой с собеседником

    можно ли это все провернуть без единой системы вознаграждения?

    Зачем нужно выделять вообще эти шаблоны
    чтобы планировать, коротко объяснять (хешировать, кодировать)

    Допустим у нас есть робот
    У него есть несколько каналов данных
    пространственная сцена, только перед камерой
    звук, пока без направления
    осязание (оказание сопротивления при движении)

    Робот помещается в сцену
    При повторяющихся дейсвтях в пределах фильтра сохраняет шаблон со всех трех типов датчиков

    В нейросетях похоже работает - свертки это шаблоны
    только они детализированы и не образуют высокоуровневого языка
    + проблемы с производительностью

    уход в высокоуровневость языка решает обе эти проблемы

    идея аналогичная софту со словами (то что до этого делал)
    предметная область морзянка
    сначала фильтра на длинный - короткий сигнал из единичек или на арабских цифры
    потом на их основании боллее высокоуровневая логика

    то что обозначено цирами)
    по пунктам выше, это я пытаюсь создать поиск шаблонов
    но при этом сам поиск жетско закодирован со своими зонами внимнаия


    будем искать шаблоны не больше динной пять
    пусть это будет железным ограничением

    если вспоминать про камеру,
    то там моделирование среды придется писать в размытом виде
    есть воксели, меши, точки, 
    мне нужны вероятности
    или нечеткое положение
    положения друг о друге хранятся в иерархии
    иногда составляемые нтревиальным образом

    например не стол в комнате, на столе монитор
    а в комнате монтор, он на столе

    Все эти игры с воссозданием картинки в симуляторе сначала проделать бы

    Ну вывиду я все эти индексы шаблонов в 1000 строке
    Как будут добавляться новые шаблоны?
    Нужно сразу думать о генераторе шаблонов

    Получается, я делаю подбор сверток
    отличие от сетей в том, что я руками просматриваю все свертки и 
    к имеющимся сврткам буду прибавлять еще
    из имен маленьких сверток образуются болшие более абстрактные
    абстрактные свертки из разных источников должны работать в едином пространстве имен
    
    попробовать получить наблоны на ноликах и еденичках
    потом попробовать заменить id на слово "один" " два" "три"
    оперируя словами симулировать похожие поледовательности
    или посупаемые на вход последовательности обозначать словами

    вроде возможно потом перейти на 2д и 3д

    как будет себя на длинной последовательности 111111111
    если известен шаблон только 111 (три)
    будут перекрестия
    нужно помечать подходящие последовательности
    у каждой цифры есть свой индекс, как с понтяием и временем в предыдущем софте

    такая иллюстрация придумалась
    можно через тк интер

    одна бегущая строка
    есть кнопки со вставками групп едениниц (двойки, тройки)
    при нажатии на кнопку в строку встраивается шаблон
    программа ловит данную строку, генерирует свертки
    осуществляет подмену в своей бегущей строке

    можно не бегущие строки а просто статичные строки с шаблонами где-то посередине

    не корректно это называть сверткой, т к свертка выкидывет чать информации

    00010000100000100000100010

    0110001100010001100001000110

    001110011000100111010101110

    пытаться найти наболее длинные шаблоны и выкидывать полностью нулевые

Каждый шаблон кодируется знаком
в результате вся страка пишется новыми знаками
приоритет оттдается самым длинным знакам

На основании какого критерия агенту захочется использовать знаки
На основании свойства языка - желать мнимизировать длинну слов для общения

Сразу в одно из самых сложных
Облако точек с подвижными объектами классифицируется знаком подвижный
Можно с очень низким разрешением

Позже перейдем от одномерной строки к 3хмерной.

Строку можно сделать бегущей равной максимальной длинне окна для знака
Первая строка в 1000 символов - это предобучение популярным шаблонам.
Бегущаяя - обчение на ходу.
Добавляютмся новые шаблоны к уже существующим.

Цифры можно заменить на буквы.
Тогда шаблон уже не в повторении одинаковых символов заключается, а скорее в их наличии.
Подключаем ранее примененные тезисы, что знак активирует программы.
Получается то, чем я сейчас занимаюсь на строке - это скорей детекция знаков.

Началось все с того, что я попытался выделить определение цифр.
Исходя из последних соображений, определение цифры четыре - это один, один, один, один.
Если я на прошлом разработанном шаблоне попытаюь написать четыре, то получу одну стрелку к слову один.
Мне нужно как минимум четыре стрелки и едеицы должны представлять из себя разные экземпляры.
Я же уже хотел вводить метку времени каждому слову.
Хотел ввод кажого слова сделать, а не предложения целиком.
Можно время присваивать предложени. а дробную часть записанной секунды делить на количество слов.
В таком случае за интерфейс не придется браться, а то я уже про сайт хотел вспоминать.

ЗАДАЧА
Сделать метку времени у каждого предложения.
Каждому слову в локальном графе присваиватся время предложения в секундах.
Добрные части секунды делятся на количество слов через пробел.
Пишется влокальный граф в абсолютных еденицах.
Заносим определние четверки.
Переводим в глобальный граф с относительными метками времени.
Главное, чтобы все времна четырех единиц не были одинаковыми.
Тоже можно отразить в определении.


Так же остается не проработнным вопрос еденицы, как меры измерения.
Сначала появляется желание измерять, а потом цифры.

Заглянул на страничку википедии с метрологией
Из интересного
Одна из аксиом
Любое измерение есть сравнение.

Единица измерения - положительное сравнение с историческим эталоном.

Сравнение - операция разницы даннх с датчика и данных с памяти исторического эталона.

Разница - железная программа.
Для меня это вычитание графов.

секунда - единица времени

единица - 1

1 - результат с железного сравнения.

Завтра попробовать построить граф как должно быть со всеми этими мыслями в драв ио.

если я введу метки времени, как объяснять одновременные событиями
метку времени в отдельную ноду выносить
получится время со временем ввода

-----

Начал рисовать
последовательность единиц для цифр напоминает числовую прямую

Для простоты работы предлягаю времена считать от начала запуска программы
(в локальном графе)

Нарисовал схемку, как я представляю цирф.
Не у всех нод есть отметка времени.
Думаю, когда начну делать метки времени на общую картину это не повлияет.

Подумал, что синонимы еще придется делать.
Можно сделать словарь с переводом цифр в цифры прописью пока.
Вспомнил, что может быть несколько определений.
Для выбора определения нужен контекст.
Начну все эти зависимости в схему добавлять.

ЗАДАЧА
Вспомнить все диалоги
Пересмотреть все старые диалоги на предмет добавления времени к каждому слову
+ способ организации связи в каждом слове посмотреть

-------------------------

Противоречие
Сейчас при употреблении одного и того же слова дважды, - 
втророй раз для слова не создается файл, а только прокидывается связь, если она нужна.
Это делается для того, чтобы показать, что используется один и тот же класс.

Я хотел показать несколько экземпляров одного класса.
В частности класса единица на числовой прямой.
Экземпляры я думал помечать экземляры временной меткой их употребления (относительной или абсолютной)

Вопрос в том как хранить классы и экземпляры.
Сейчас все на файлах сделано.

ЗАДАЧА
предварительно
храним экземпляры в виде списка времен упоминаний в файле класса слова
а как же связи между экземплярами?
неужели другие кружочки?

Еще раз пытаюст вспомнить процесс измерения
В Живом организме есть показания с датчика
они в попугаях
или через генетическую информацию или через корректировку, вырабатываются эталонные единицы
опять же в попугаях
с которыми сравниваются показания
ответ на логику поступает в попугаях со знаком (+43 попугая или -32 попугая)
дальше механизм регуляции

В данном случае мы по аналогии с генами заводим еденицы измерения в попугаях 
и операцию сравнения
Все это программируется железно
Допускается, что сам агент должен смочь переопределить эти механизы, эталоны
но позже. Над реализацией пока я не думал, но уверен - придумаем.

Рассмотрим две предметные области
Время и числовую прямую.
Время это физическая величина, основанная на датчике.
Датчик возвращает показания в типе данных int или float
у нас есть ключевое слово "разница" для дальнейшей логики

Так же у нас есть цифры
это уже высокоуровневые знаки
с помощью цифр мы пытаемся показания с датчика времени
мне кажется пока надо забить на все это
вернемся, когда будет самоанализ.
Не получится что мы прийдем к жесткому типизированию?

из цифр обозначающих время не получится вычесть обозначающие метры
Человек так то может видеть в том что пришло от датчика только цифры и игнорировать время и метры
Значит цифры отдельно физ величины отдельно

Вернемся к нашим баранам
как объяснять времена и цифры

На уровне средней школы, цифры объясняются с помощью числовой прямой
На уровне наальных классов на счетных палочках
Получается нас пока интерисуют только палочки

Датчик времени должен образовывать кусок графа в локальном
из узлов цифра с датчика, указание названия датчика, объединение этих двух под меткой номер ...

Может сначала обучить цифрам, а потом показаниям с датчика


Пример диалога
Переднами пять палочек
к
о
ж
з
г

обозначим каждую за единицу

это самое сложное
хожу вокруг да около
мне нужно признать, что нужны экземпляры класса
цифра два - шаблон со связью на экземпляр класса и на экземляр такого же класса
Раз есть классы, значит есть иерархия
Множество два, три, четрыре образуют класс цифры
Обратное наследование
когда генерируем родителя из множества детей

получается в овалах создаются не знаки - классы, а экземпляры
как только появляется новое слов - для него создается файл определения, но это определение класса


ЗАДАЧА
создать отедльную ветку
добваление в файл ноды списка времени упоминания абсолютного
именить функцию отрисовки
повторить диалог секунда только с цифрами
Вывод определения, десятки, синонимы, алгоритмы

как объяснить что палочка - это единица
когда говорят обозначим за единицу - подразумевается , что будут расчеты

объясним каждое из слов

два - шаблон со связью на экземпляр класса и на экземляр такого же класса

шаблон - операция наложения части графа на граф
подразумевающеяся как само собой разумеющееся. Можно не упоминать в определении
кодится железно

мне понадобится слово "любой"
и упоминание что все слова это экземпляры
по идее любой это слово мусорное
нужно сразу сообщать ключевые отличия

Было бы все в ООП иерархии
можно было бы принадлежность к классу указать

синонимы:
единица
сущность
вещь
что-то

у всех у них есть определение - любой экземпляр

Я по сути сейчас меняю сущность определения
раньше это был кусок графа
я мог сравнивать один кусок с другим куском

на_что_похоже палочка палочка
ответ: два
на_что_похоже точка точка
ответ тоже должен быть два, хотя в определнии точек нет

два - шаблон со связью на экземпляр класса и на экземляр такого же класса
переведем на язык без окончаний и мусорных слов

два - экземпляр_класс_1 экземляр_2_класс_1

Упираемся в определение классов и экземлпяров

Когда пишется новое слово
сразу же создается файл класса и запись об экземпляре
Когда запоминается определение берутся классы экземпляров в графе и записвваются в файл (в json список с элементами)


диалог
палка (создается файл палка, в нем json, в json спиок с единственным членом - меткой времени) (отрисовка овала со словом палка с надписью времени курсивным шрифтом)
палка (проверка существования файла, если существует, то добавление в список метки времени) (перерисовка)

хотелось бы как то повзаимдействовать с одной из палок. Но если сказать снова палка
будет третий экземпляр, а мне нужно обратиться к одному из прошлых
Варианты указателя
-пальцем (у нас нет камер и знаний об точке внимания)
-добавлением нового слов, например "первая палка" (знаний о слове первая тоже нет)
-меткой времени через спец символ (костыль, и придется постоянно держать граф открытым)
-добавить служебные слова "последний", предпоследний" (времена сравнивать)
думаю остановимся на спецсиволе

добавление класса и экземпляра есть

может объяснение слова любой это железно и реализовывать надо сразу в коде проверкой на файл или член списка или из ООП

продолжим наш диалог
точка (по аналогии с палкой еще один класс)
точка (аналогично)

класс и экземпляр - мне нужно дать определения этим словам, чтоб дать определение двойке

если отражать все связи на графе, то все узлы будут связаны со словом экземпляр
формально - это правильно
так эе это синоним слова "любой" и с этим словом тоже все может быть связано
мне кажется железно хранить все эти связи бессмысленно
нужно выработать шаблон, при накладывании которого мы бы получали "true"

Если я введу предложени описывающее определение уже существующее в одном из классов

Из википедии: класс - группа предметов или явлений, обладающих общими признаками

Есть вариант написать определение двойки на питоне
два - это когда оба экземпляра ссылаются на один и тот же файл или имена в заголовке овальчика совпадают
получается целый алгоритм

вспоминаютмся первороднве определения
я мытаюсь двойке второродное дать

промежуточный итог
два - палка$1 палка$2
два - точка$1 точка$2

перед цифрами нужно рповернуть диалок "секунды" со словами класс и экземпляр

допустим эти слова будут первородными

вспомнить как исполняются слова и в каким местах первородные, в аких второродные

Может пересмотреть алгоритм выполнения предложения
сейчас последовательно выполняются слова
если нет кода пропускаются
передаются соседи как параметры
результат выполнения в новую ноду или в json (с последним не помню)

возникал мысль, что если слово входит в шаблон то true вместо слова занимать
тогда все предложние прваратится в список true и false 
с каким шаблоном срванивать
со всеми?
когда сравниваем кусок графа , сравнение идет со всем графом

может вспомнить о идеальном и о переделах

определение любой из словаря - Всякий, каждый.
то есть они на множество намекают.

два - значит на питоне кодим
числится в паке с файлами и ...

как проверять будем

на что похоже - палка палка

тогда и определение класса на питоне

при на что похоже - палка палка должно быть уждачным совпадение со словом экземпляр
просто слов палка это действительно экземпляр
но тут надо принять во вниание что сейсчас "палка палка" в одной фокус группе
это факт наличия в графе такого же элемента

опять железное определение двойки

ладно пофигу делаем все железно

---------

Какие операции над словом секунда производились

1) создание слов из которых можно собрать определение
2) дача определения
3) команда на вывод опрелеления
4) сравнение левого графа с сохраненным определением и подверждение совпадения
5) так и не дошло дело до оперирования опрелением

так же нужно с двойкой

я тут подумал, как в экземпляре указывается ссылка на класс
сразу же ответ
имя_класса$номер_экземпляра
так же подумал, что имя экземпляра может быть не только цифренным. Ему тоже можно имена давать
Серазу же ответ: если можно давать имена - это уже классы.
с экземплярами только арифметические действия выполнять.

Новость в том, что раньше я определение только из овальчиков (классов) составлял
а теперь еще и экземпляры, еще и не важно какие

Это пол беды, наличе класса - существование в списке файлов
наличеие двух экземпляров - существование в массиве экземпляров или где они там будут храниться.
(в фалйе или питон объекте).

Вторая половина беды - как будет выполняться данный код.

На какие типы вопросов нужно будет уметь отвечать -

1) сколько палка палка

по аналогии
на что похоже разница 3 4
ответ секунда

слово сколько пока можно опустить

соответсвенно должен быть второй вариант

2) скажи палка два раза
отвтет палка палка

то есть из ситуации в знак
и из знака в ситуацию

Еще раз по секунде
на_что_похоже 1 разница время
из ситуации в знак

Из знака в ситуацию с секундой не делал
выведи на экран через 10 секунд

назовем из ситуации в знак "прямым вопросм"
из знака в ситуацию "обратным вопросом"

в прямом вопросе хотелось бы использовать код на_что_похоже
но не все так просто
потому что при даче определения мы на палках объясняли, а сейчас на куржках спрашиваем
нужно или сразу объяснять на слове экземпляр и класс
или делать на питоне

так было со словом "разница"

в одной ситуации слово исполнялось, в другой нет
тут нужно разобраться что из реплик с разницей могло быть прямым или обратным вопросом
а что ни тем ни другим
и вспомнить вообще общий пайлайн исполнения любого предложения
это первый важный вопрос
второй - как измениться пайплайн, если слова вводить по одиночке (+ про метку времени еще не забыть)

Выполнение предлжения:
поледоватьель выполняются все слова с передачей в параметров соседей
если кода нет, то пропускаем
результаты в ответ в новые узлы

с прямым вопросом "палка палка"
в обоих палках нет кода
как же определить, что это двойка
можно заменить на класс$1 класс$2
кода в них все равно не будет.
значит нужно вызывать слово на_что_похоже
его походу надо всегда вызывать на равне с записью в граф всех слов

даже если бы мы не спрашивали, двойка это или не двойка
смысл двойки все равно должен всплывать в оперативном ответе
получается на одно и то же предложение возможно несколько ответов
шикарно, зафиксировать, придется выбирать

если добавить слово "сколько" так еще и разные части предложения должны выдавать разные ответы
но о частичных ответах как и о параллельном выполнении слов пока не думаем
Например
предложение "сколько палка палка всего"

сколько палка
палка палка
палка всего

каждый из этих кусков можно пропустить через сравнение с частью графа

обратный вопрос из знака в ситуацию
вопрос: два палка
ответ: палка палка

с точки зрения экземпляров в ответах могут как говориться уже упомянутые экземпляры, так и новые сгенерированные
если в графе достаточно экземлпляров, можно старые озвучить
которые использовались еще при прямом вопросе

тут в принципе логично
попадая в код слова два с передачей соседа
генерируется новый граф с необходимым количеством экземпляров и возвращается

диалог вырисовывается точнее


вопрос: сохрани_определение два любой_класс$любая_цифра два тотже_класс$кроме_упомянутой_цифры
ответ: 
вопрос: палка$1 палка$2
ответ: два
вопрос: два палка
ответ: палка$3 палка$4

только определение двойки сразу в коде нужно, а то заколебусь

постепенно проработанность мира в графе будем как ввысь так и вниз расширать
то что двойка есть первородное определение, а будет второродным как раз расширение вниз

как бы выглядел диалог с починеной секундой с добавлением экземпляров и постоянной срвнением с части графа с остальным графом

Ввод: время 1658921962
Вывод: 
Ввод: время 1658921963
Вывод: 
Ввод: выполни_с_параметрами разница 1658921963 1658921962
Вывод: 1
Ввод: сохрани_определение секунда 1 разница время
Вывод: 
Ввод: выведи_определение секунда
Вывод: 1 разница время
Ввод: на_что_похоже 1 разница время
Вывод: секунда

а тут и не нужны экземпляры были
поэтому можно писать сразу классами
все равно счетчик дальше $1 не уходил

и сравнние с частью графа вызывается только один раз в конце и то пренудительно

ладно, начнем рисовать в коде двойку, потом запустим секунду посмотрим, что сломается

ну если уж формально

Ввод: время$1 1658921962$1
Вывод: 
Ввод: время$1 1658921963$1
Вывод: 
Ввод: выполни_с_параметрами$1 разница$1 1658921963$1 1658921962$1
Вывод: 1$1
Ввод: сохрани_определение$1 секунда 1 разница время (тут можно как наставить всем $ так и нет т к классы)
Вывод: 
Ввод: выведи_определение секунда (то же самое в экземпляровости не нуждаемся. в строчках ниже тоже)
Вывод: 1 разница время
Ввод: на_что_похоже 1$1 разница$1 время$1 (разве что слово на что похоже можно явно не писать)
Вывод: секунда

можно определить приоритеты
сначало идет выполнение всех слов
потом сравнение куска графа

оба этих сценария придется делать перед выбором из нескольких ответов

вот и модернизировали общий пайплайн

слово на что похоже скорей всего придетс добавить в пайплайн
слово не удалять, а в нем просто ссылку на функцию сделать

-------

еще пишем все без долора
идентификаторы присваивабтся экземплярам по времени

-------

добавил экземплярность по вермени через долор к каждому слову
первое место, где сломалось - выполнение слов
сравнение слова с файлом

либо бегать по всему коду и чичтить слово до долора
либо хранить экземпляры где -то отдельно
и как потом к ним обращаться?
то что с долором сейчас используется для отрисовки
а где будет еще использоваться?
по идее экземпляры хранятся в списке в файле класса
ссылки в файле грфа тоже сразу с долорами используются

бесит, что это строки, которые парсить нужно, а не объекты

может монгоДБ ?

я конечно могу отремонтировать, но сколько еще будет ломаться

красивую архитектуру можно составить, только попробовав многие альтернативы

https://sofakingcode.medium.com/экскурс-в-графовая-базу-данных-neo4j-9d5c515186e8

конкретно сейчас при диалоге секунды в фал минус ломется приведение к int. т к долор

-------------

еще раз общий пайплайн

предложение напечаталось в консоль
к кажому слову добавилась строка через долар со временем печати и порядком в предложении
выполняются поочередно все слова с параметрами в виде соседей
    ищется код слова
    в субпроцессе выполняется с переданными параметрами
        ЧИСТИМ ОТ ДОЛОРА САМО СЛОВО
        ЧИСТИМ ПАРАМЕТРЫ
        косяк - пораметры не именованные (важен только порядок)
        промежуточные вычисления для других слов записываются в json файл
полученные вычисления в виде нод записываются в классы и связи (граф)
граф перерисовывается
    БЕРЕМ НЕЧИЩЕННОЕ НАЗВАНИЕ
все слова из предложения проверяются на новизну
    косяк - граф не перерисовывается

Если бы ты сделал на классах и БД

посмотреть разные БД
скорей всего на них запросы будет пиать неудобно

решил поппробовать с бд поработать neo4j

если будет удобно работать перепишусь на класс (для экземпляровости)

поиск похожего графа надеюсь с помощью neo4j решить

создам кусок грфа (звездочка)

соединю 4 звездочки в одну большую
и спрошу сколько звездочек - ответ должен быть 4
прошу заметить, что не 5, хотя вместе они образуют звезду
потому что слово вместе - должно образовывать отдельный график - он и есть пятый

все зависит от того какой там язык запросов

шпблон палка палка нужен

получается над словом два должна быть операция сравнения (от среды к знаку)
и чтения из знака в среду (в чтении тоже сравнение)
у каждго класса или экземпляра должны быть эти методы

поискать по запросу
neo4j python example

--------------

https://console.neo4j.io/?product=aura-db
зашел под гугловским аккаунтом

https://neo4j.com/download/
локальные версии не скачиваются

https://neo4j.com/developer/python/
официаальная страничка
первый пример с ошибкой выполняется

https://neo4j.com/developer/example-project/
не разбирал

https://github.com/orgs/neo4j-examples/repositories?q=python&type=all&language=&sort=
тоже не разбирал

