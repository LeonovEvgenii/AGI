    Мысли в слух, потом подудаляю или распихаю по разделам
    Опять я программирую слово "=" на питоне. Запись производится в файл.
    Я искал универсальное хранилще для знака и понтяия и решил, что это будет файл.
    В файл можно записать любые аспекты.
    Идеальная ситуация, когда выделяются новые понятия.
    Эта ситуация возможна тогда, когда идет текст. Формируется граф.
    Появляются новые слова, они добавляются в граф. Дальше необходимо понять
    закономерность, какую они обозначают. Генерируется набор функций из известных
    элементов и выбирается наилучшая гипотеза.
    Еще вариант создания нового понятия - обозначение повторяющиеся последовательности слов
    от предложения к предложению.

    Каждый раз когда мы добавляем глагол - у него пишется алгоритм.
    А когда добавляем существительное - разве нет?
    Слово может все что угодно содержать, есть понятия, которые сложные вещи
    описывают и поэтому отсутсвие алгоритма не обязательное свойство существительного.

    Ничего страшного нет, что ты пишешь питоновский код в слово "=". Когда будешь
    решать задачки по программированию по сложнее, там будут определения второго рода.

    Еще примеры
    поиск макисмума сначала из 3 чисел
    потом из 5 (уже сортировка массива будет, потом выдача первого)
    потом максимальное четное (сначала сортировка, потом четное)

    Работа с бесконечностями
    точка закрашенная область, меньше которой закрасить нельзя
    подводка к определению бесконесно малый и бесконечно большой
    (точка и отрезок)

    Продолжаю рассуждать про переменные.
    Один из вариантов - перейти сразу к объяснению одномерного пространства.
    Подразумевалось, что ЯП будет объяснен на ЕЯ.
    Если объяснять сохранение многих значений во многих переменных, то все они будут
    иметь связи со словом "хранит".

    Если рассматривать перезапись одной и той же переменной (a = 1 a = 2 a = 3), то на текущий момент
    в графе показывается, a имеет связь со всеми тремя значениями и не отображает последнее хранящееся значение.
    Это из-за того, что не учитывается порядок ввода. Придется для каждого узла метку времени ыыодить.
    Не используемые значения выкидывать. В результате я играю в компилятор.

    Если использовать уже существующий шаблон, то нужно чтоб слово "=" протягивало связь от переменной к значению.

    В таком случае нужно перед каждой строкой говорить, что это переменная и в нее идет запись значения.
    Или еще лучше, что сейчас мы будм программировать.

    Получается из за контекста используются другие значения.

    Получается это вникание в синтаксис ЯП, а не алгоритмы.
    Чтобы объяснять алгоритмы на ЕЯ, нужны местоимения, лица и обозначение объектов над которыми
    можно производить операции.

    Резюмируем
    Для ЯП нужен контекст.
    А алгоритмы попробуем реализовать на словах, а не на операторах питона.

    Может Маша и яблоки?

    маша хранит одно яблоко
    даша хранит два яблоко
    сколько яблоко всего

    Вообще не очевидно что такое "один", "два", "всего".

    Может симулятор подключить и объекты расставлять.
    Маша один кубик, Даше еще один.
    Яблоки шарики. Можно про воксели вспомнить и про классификацию.
    Слово "всего" подсчет количества объектов одинакового класса?

    Что если самому попробовать составить граф определений топа 10 популярных слов

    Есть определения, которые отталкиваются от физических величин.
    Есть математические и философские определения. Можно сказать, что информационные.
    Математические наверняка когда-то были связаны с физическими и образовались из них.
    Если я хочу объяснить слово "четыре", значит мне придется в реальности показывать
    разные четверки объектв и говорить, что их что-то объединяет. А именно - количественность.
    Числа - отражения количественности величин.
    Переменные - псевданимы и обозначения величин. Присвоение имени.
    Так же есть классы и экземпляры.
    Экземпляры отличаются друг от друга только назвнием.
    Например - "яблоко" и "другое яблоко"
    Числа это тоже классы.
    У числа 4 могут быть экземпляры. 4 обозначющее яблоки и 4 обозначающее людей.
    4 обозначающий абстрактный шаблон.

    Получается к понятиям нужно добавить экземплярность.
    На все ли понятия накладывается экзмплярность или есть исключения.

    Работа с симулятором.

    Понятие кодируемое буквами это не только возможный питоновский код, но еще и 
    список объектов, веселей в симуляторе.

    Как эе быть с переменными?
    Сначала модель цифр сделать из реальности.
    ЯП по сути это калька с реальности для применения определенных подсчетов.
    Операторы - упращенная версия реальных действий , только с определенными свойствами.

    Может попробовать дать определение каким-нибудь глаголам.

    Резюме
    1) определение глаголов
    2) топ 10 граф
    3) рассужденния об экземплярности каждого понятия (например слово "год")
    4) введение определения одномерного пространства
    5) поиск симулятора

    Определение глагола.
    Например передвигаться - изменять свою координату.
    Это шаблон, который можно сравнить с уже совершенным или планируемым действием.
    (локальным графом). и сказать похож или не очень.

    Контексты и фантазии можно представить как записи локального графа в глобальный
    с пометкой когда он был сделан и при каких обстоятельствах.

    Практически любые определения упираются в подсчет объектов.
    Которые, я хотел бы объяснять в симуляторе.
    Допустим симулятор у меня уже есть. Как бы я это объяснял?

    Рисуем иллюстрацию

    1100100001000101

    сколько единиц?

    есть определение слова единица и это шаблон.
    Чтобы понять вопрос, должно быть жестко закадировано понятие шаблона.

    Зачем обязательно в грфику уходить, представляя одномерный массив 1100100001000101
    или многомерный в симуляторе.

    я так же могу в строку через пробел записать 1 1 0 0 1 0 0 0 0 1 0 0 0 1 0 1
    и спросить сколько единиц?

    Люди в отличие от животных научились мыслить абстрактно, а не только принимать показания с датчиков

    строка - это сырые показания.

    абстрация - это использование одних признаков и неиспользование дргугих.

    В ЯП происходит операция сложения в ячейку памяти и сравнение с шаблоном.

    Для любых других цифр - 2, 3, 4 и т д будут дургие шаблоны.
    Если бы я запустил эту строку на текущей реализации программы, то получил бы граф из двух элементов.
    То есть время создания узла в локальном графе - обязательный компонент.
    Может тогда и тип ввода изменить по словам.
    Предложения это тоже абстракии. Первоочередное - это одиночные знаки.

    Если человеку сказать эту же последовательность, он среди всего многообразия вываленных на него признаков
    подчеркнет именно количественность. Не важно считает он это на слух или пишет на бумаге.

    Свойство за которым я гоняюсь - это генерация шаблонов и их использование в любом типе сигнала.

    На каком языке будет записываться этот шаблон?
    Должен ли он использовать те же кирпичики из которых состоит сам сигнал с датчика.
    В живых орггнизмах язык вернего уровня тоже работает поверх ассемблера на генах.
    Нейросети подбирают функцию любой сложности к сигналу.
    Твой подход чем-то отличается от всех дргих попыток постройки интеллектуальных агентов?
    Все началось с отражения связи между словами в тексте.

    возьмем последовательность

    110001100011000 и т д

    Рассмотрим окно []
    запихаем сначала 1 символ из последовательности, пробежимся окном по последовательности
    вычислим ошибку
    потом двумя [11]
    потом тремя [110]
    [1100]
    до [11000]
    Если увеличить окно, то или ошибка перестанет расти
    или период повторения будет уменьшаться

    как подбирать сложные зависимости, когда следующий элемент вычисляется на основ епредыдущего

    нам ведь не надо предсказывать, хотя выделение шаблона, это по сути предсказания

    Тебе нужно было всего-то отпределение цифры на языке твоей проги.

    по сути даже на этой беспорядочной последвательнсти можно выделить шаблоны

    1 - 1
    11 -2
    111 -3
    и т д

    у знака есть id 
    знак задается через положительно подкрепление
    подкрепление, значт есть целевой критерий
    У живых оргнаизмо целевой критерий покормить или похвалить
    может цифры через покормить создавались

    создать симулятор с бегущей строкой, посмотреть как он выработает шаблоны цифр
    может от цифр будет недалеко и до букв и слов

    -----------------

    составил скриптик по поиску шаблона в строке
    цифра три - три единицы подряд
    усложним определение цифры три
    это элмемнт и элемент и элемент
    все элементы равны
    в определении йифры не должна участвовать сама цифра
    нужна какая-то оперативная память, где будут собираться шаблоны
    нужно воспроизвести генерацию шаблона

    в принципе есть надежда, на использование существующего софта
    только вместо единиц и нулей слова с обязатеьными метками времени.
    Метку времени походу придется сделать в файле описания слова, наряду
    с полями имя, определения, питоновский файл.

    1) рандомная генерация строки длинной 1000 скажем
    2) интерисуемся пока шаблонами только из единиц, хотя други тоже возможны
    но мне пока не нужны
    3) берем шаблон "1" и бежим по строке собирая индексы
    4) увеличиваем длинну шаблона на еще +1, повторяем вывод
    чисто теоретически мы найдем все вхождения
    можно даже переписать строку заменив найденные шаблоны на арабские цифры.

    меня смущает, что в написанном коде будут знаки +
    когд, который пишется, это симуляция высокоуровневой деятельности
    если бы было на мозгу человека, то он бы в оперативное поле или фантазию
    помещал два фрагмента и искал сходство

    Ребенок без труда замечает, что два каких-то предмета могут быть одинаковыми

    Потом он может зметить что удобно помечать определенное количество знаком
    и обмениваться инфой с собеседником

    можно ли это все провернуть без единой системы вознаграждения?

    Зачем нужно выделять вообще эти шаблоны
    чтобы планировать, коротко объяснять (хешировать, кодировать)

    Допустим у нас есть робот
    У него есть несколько каналов данных
    пространственная сцена, только перед камерой
    звук, пока без направления
    осязание (оказание сопротивления при движении)

    Робот помещается в сцену
    При повторяющихся дейсвтях в пределах фильтра сохраняет шаблон со всех трех типов датчиков

    В нейросетях похоже работает - свертки это шаблоны
    только они детализированы и не образуют высокоуровневого языка
    + проблемы с производительностью

    уход в высокоуровневость языка решает обе эти проблемы

    идея аналогичная софту со словами (то что до этого делал)
    предметная область морзянка
    сначала фильтра на длинный - короткий сигнал из единичек или на арабских цифры
    потом на их основании боллее высокоуровневая логика

    то что обозначено цирами)
    по пунктам выше, это я пытаюсь создать поиск шаблонов
    но при этом сам поиск жетско закодирован со своими зонами внимнаия


    будем искать шаблоны не больше динной пять
    пусть это будет железным ограничением

    если вспоминать про камеру,
    то там моделирование среды придется писать в размытом виде
    есть воксели, меши, точки, 
    мне нужны вероятности
    или нечеткое положение
    положения друг о друге хранятся в иерархии
    иногда составляемые нтревиальным образом

    например не стол в комнате, на столе монитор
    а в комнате монтор, он на столе

    Все эти игры с воссозданием картинки в симуляторе сначала проделать бы

    Ну вывиду я все эти индексы шаблонов в 1000 строке
    Как будут добавляться новые шаблоны?
    Нужно сразу думать о генераторе шаблонов

    Получается, я делаю подбор сверток
    отличие от сетей в том, что я руками просматриваю все свертки и 
    к имеющимся сврткам буду прибавлять еще
    из имен маленьких сверток образуются болшие более абстрактные
    абстрактные свертки из разных источников должны работать в едином пространстве имен
    
    попробовать получить наблоны на ноликах и еденичках
    потом попробовать заменить id на слово "один" " два" "три"
    оперируя словами симулировать похожие поледовательности
    или посупаемые на вход последовательности обозначать словами

    вроде возможно потом перейти на 2д и 3д

    как будет себя на длинной последовательности 111111111
    если известен шаблон только 111 (три)
    будут перекрестия
    нужно помечать подходящие последовательности
    у каждой цифры есть свой индекс, как с понтяием и временем в предыдущем софте

    такая иллюстрация придумалась
    можно через тк интер

    одна бегущая строка
    есть кнопки со вставками групп едениниц (двойки, тройки)
    при нажатии на кнопку в строку встраивается шаблон
    программа ловит данную строку, генерирует свертки
    осуществляет подмену в своей бегущей строке

    можно не бегущие строки а просто статичные строки с шаблонами где-то посередине

    не корректно это называть сверткой, т к свертка выкидывет чать информации

    00010000100000100000100010

    0110001100010001100001000110

    001110011000100111010101110

    пытаться найти наболее длинные шаблоны и выкидывать полностью нулевые

Каждый шаблон кодируется знаком
в результате вся страка пишется новыми знаками
приоритет оттдается самым длинным знакам

На основании какого критерия агенту захочется использовать знаки
На основании свойства языка - желать мнимизировать длинну слов для общения

Сразу в одно из самых сложных
Облако точек с подвижными объектами классифицируется знаком подвижный
Можно с очень низким разрешением

Позже перейдем от одномерной строки к 3хмерной.

Строку можно сделать бегущей равной максимальной длинне окна для знака
Первая строка в 1000 символов - это предобучение популярным шаблонам.
Бегущаяя - обчение на ходу.
Добавляютмся новые шаблоны к уже существующим.

Цифры можно заменить на буквы.
Тогда шаблон уже не в повторении одинаковых символов заключается, а скорее в их наличии.
Подключаем ранее примененные тезисы, что знак активирует программы.
Получается то, чем я сейчас занимаюсь на строке - это скорей детекция знаков.

Началось все с того, что я попытался выделить определение цифр.
Исходя из последних соображений, определение цифры четыре - это один, один, один, один.
Если я на прошлом разработанном шаблоне попытаюь написать четыре, то получу одну стрелку к слову один.
Мне нужно как минимум четыре стрелки и едеицы должны представлять из себя разные экземпляры.
Я же уже хотел вводить метку времени каждому слову.
Хотел ввод кажого слова сделать, а не предложения целиком.
Можно время присваивать предложени. а дробную часть записанной секунды делить на количество слов.
В таком случае за интерфейс не придется браться, а то я уже про сайт хотел вспоминать.

ЗАДАЧА
Сделать метку времени у каждого предложения.
Каждому слову в локальном графе присваиватся время предложения в секундах.
Добрные части секунды делятся на количество слов через пробел.
Пишется влокальный граф в абсолютных еденицах.
Заносим определние четверки.
Переводим в глобальный граф с относительными метками времени.
Главное, чтобы все времна четырех единиц не были одинаковыми.
Тоже можно отразить в определении.


Так же остается не проработнным вопрос еденицы, как меры измерения.
Сначала появляется желание измерять, а потом цифры.

Заглянул на страничку википедии с метрологией
Из интересного
Одна из аксиом
Любое измерение есть сравнение.

Единица измерения - положительное сравнение с историческим эталоном.

Сравнение - операция разницы даннх с датчика и данных с памяти исторического эталона.

Разница - железная программа.
Для меня это вычитание графов.

секунда - единица времени

единица - 1

1 - результат с железного сравнения.

Завтра попробовать построить граф как должно быть со всеми этими мыслями в драв ио.

если я введу метки времени, как объяснять одновременные событиями
метку времени в отдельную ноду выносить
получится время со временем ввода

-----

Начал рисовать
последовательность единиц для цифр напоминает числовую прямую

Для простоты работы предлягаю времена считать от начала запуска программы
(в локальном графе)

Нарисовал схемку, как я представляю цирф.
Не у всех нод есть отметка времени.
Думаю, когда начну делать метки времени на общую картину это не повлияет.

Подумал, что синонимы еще придется делать.
Можно сделать словарь с переводом цифр в цифры прописью пока.
Вспомнил, что может быть несколько определений.
Для выбора определения нужен контекст.
Начну все эти зависимости в схему добавлять.

ЗАДАЧА
Вспомнить все диалоги
Пересмотреть все старые диалоги на предмет добавления времени к каждому слову
+ способ организации связи в каждом слове посмотреть

-------------------------

Противоречие
Сейчас при употреблении одного и того же слова дважды, - 
втророй раз для слова не создается файл, а только прокидывается связь, если она нужна.
Это делается для того, чтобы показать, что используется один и тот же класс.

Я хотел показать несколько экземпляров одного класса.
В частности класса единица на числовой прямой.
Экземпляры я думал помечать экземляры временной меткой их употребления (относительной или абсолютной)

Вопрос в том как хранить классы и экземпляры.
Сейчас все на файлах сделано.

ЗАДАЧА
предварительно
храним экземпляры в виде списка времен упоминаний в файле класса слова
а как же связи между экземплярами?
неужели другие кружочки?

Еще раз пытаюст вспомнить процесс измерения
В Живом организме есть показания с датчика
они в попугаях
или через генетическую информацию или через корректировку, вырабатываются эталонные единицы
опять же в попугаях
с которыми сравниваются показания
ответ на логику поступает в попугаях со знаком (+43 попугая или -32 попугая)
дальше механизм регуляции

В данном случае мы по аналогии с генами заводим еденицы измерения в попугаях 
и операцию сравнения
Все это программируется железно
Допускается, что сам агент должен смочь переопределить эти механизы, эталоны
но позже. Над реализацией пока я не думал, но уверен - придумаем.

Рассмотрим две предметные области
Время и числовую прямую.
Время это физическая величина, основанная на датчике.
Датчик возвращает показания в типе данных int или float
у нас есть ключевое слово "разница" для дальнейшей логики

Так же у нас есть цифры
это уже высокоуровневые знаки
с помощью цифр мы пытаемся показания с датчика времени
мне кажется пока надо забить на все это
вернемся, когда будет самоанализ.
Не получится что мы прийдем к жесткому типизированию?

из цифр обозначающих время не получится вычесть обозначающие метры
Человек так то может видеть в том что пришло от датчика только цифры и игнорировать время и метры
Значит цифры отдельно физ величины отдельно

Вернемся к нашим баранам
как объяснять времена и цифры

На уровне средней школы, цифры объясняются с помощью числовой прямой
На уровне наальных классов на счетных палочках
Получается нас пока интерисуют только палочки

Датчик времени должен образовывать кусок графа в локальном
из узлов цифра с датчика, указание названия датчика, объединение этих двух под меткой номер ...

Может сначала обучить цифрам, а потом показаниям с датчика


Пример диалога
Переднами пять палочек
к
о
ж
з
г

обозначим каждую за единицу

это самое сложное
хожу вокруг да около
мне нужно признать, что нужны экземпляры класса
цифра два - шаблон со связью на экземпляр класса и на экземляр такого же класса
Раз есть классы, значит есть иерархия
Множество два, три, четрыре образуют класс цифры
Обратное наследование
когда генерируем родителя из множества детей

получается в овалах создаются не знаки - классы, а экземпляры
как только появляется новое слов - для него создается файл определения, но это определение класса


ЗАДАЧА
создать отедльную ветку
добваление в файл ноды списка времени упоминания абсолютного
именить функцию отрисовки
повторить диалог секунда только с цифрами
Вывод определения, десятки, синонимы, алгоритмы

как объяснить что палочка - это единица
когда говорят обозначим за единицу - подразумевается , что будут расчеты

объясним каждое из слов

два - шаблон со связью на экземпляр класса и на экземляр такого же класса

шаблон - операция наложения части графа на граф
подразумевающеяся как само собой разумеющееся. Можно не упоминать в определении
кодится железно

мне понадобится слово "любой"
и упоминание что все слова это экземпляры
по идее любой это слово мусорное
нужно сразу сообщать ключевые отличия

Было бы все в ООП иерархии
можно было бы принадлежность к классу указать

синонимы:
единица
сущность
вещь
что-то

у всех у них есть определение - любой экземпляр

Я по сути сейчас меняю сущность определения
раньше это был кусок графа
я мог сравнивать один кусок с другим куском

на_что_похоже палочка палочка
ответ: два
на_что_похоже точка точка
ответ тоже должен быть два, хотя в определнии точек нет

два - шаблон со связью на экземпляр класса и на экземляр такого же класса
переведем на язык без окончаний и мусорных слов

два - экземпляр_класс_1 экземляр_2_класс_1

Упираемся в определение классов и экземлпяров

Когда пишется новое слово
сразу же создается файл класса и запись об экземпляре
Когда запоминается определение берутся классы экземпляров в графе и записвваются в файл (в json список с элементами)


диалог
палка (создается файл палка, в нем json, в json спиок с единственным членом - меткой времени) (отрисовка овала со словом палка с надписью времени курсивным шрифтом)
палка (проверка существования файла, если существует, то добавление в список метки времени) (перерисовка)

хотелось бы как то повзаимдействовать с одной из палок. Но если сказать снова палка
будет третий экземпляр, а мне нужно обратиться к одному из прошлых
Варианты указателя
-пальцем (у нас нет камер и знаний об точке внимания)
-добавлением нового слов, например "первая палка" (знаний о слове первая тоже нет)
-меткой времени через спец символ (костыль, и придется постоянно держать граф открытым)
-добавить служебные слова "последний", предпоследний" (времена сравнивать)
думаю остановимся на спецсиволе

добавление класса и экземпляра есть

может объяснение слова любой это железно и реализовывать надо сразу в коде проверкой на файл или член списка или из ООП

продолжим наш диалог
точка (по аналогии с палкой еще один класс)
точка (аналогично)

класс и экземпляр - мне нужно дать определения этим словам, чтоб дать определение двойке

если отражать все связи на графе, то все узлы будут связаны со словом экземпляр
формально - это правильно
так эе это синоним слова "любой" и с этим словом тоже все может быть связано
мне кажется железно хранить все эти связи бессмысленно
нужно выработать шаблон, при накладывании которого мы бы получали "true"

Если я введу предложени описывающее определение уже существующее в одном из классов

Из википедии: класс - группа предметов или явлений, обладающих общими признаками

Есть вариант написать определение двойки на питоне
два - это когда оба экземпляра ссылаются на один и тот же файл или имена в заголовке овальчика совпадают
получается целый алгоритм

вспоминаютмся первороднве определения
я мытаюсь двойке второродное дать

промежуточный итог
два - палка$1 палка$2
два - точка$1 точка$2

перед цифрами нужно рповернуть диалок "секунды" со словами класс и экземпляр

допустим эти слова будут первородными

вспомнить как исполняются слова и в каким местах первородные, в аких второродные

Может пересмотреть алгоритм выполнения предложения
сейчас последовательно выполняются слова
если нет кода пропускаются
передаются соседи как параметры
результат выполнения в новую ноду или в json (с последним не помню)

возникал мысль, что если слово входит в шаблон то true вместо слова занимать
тогда все предложние прваратится в список true и false 
с каким шаблоном срванивать
со всеми?
когда сравниваем кусок графа , сравнение идет со всем графом

может вспомнить о идеальном и о переделах

определение любой из словаря - Всякий, каждый.
то есть они на множество намекают.

два - значит на питоне кодим
числится в паке с файлами и ...

как проверять будем

на что похоже - палка палка

тогда и определение класса на питоне

при на что похоже - палка палка должно быть уждачным совпадение со словом экземпляр
просто слов палка это действительно экземпляр
но тут надо принять во вниание что сейсчас "палка палка" в одной фокус группе
это факт наличия в графе такого же элемента

опять железное определение двойки

ладно пофигу делаем все железно

---------

Какие операции над словом секунда производились

1) создание слов из которых можно собрать определение
2) дача определения
3) команда на вывод опрелеления
4) сравнение левого графа с сохраненным определением и подверждение совпадения
5) так и не дошло дело до оперирования опрелением

так же нужно с двойкой

я тут подумал, как в экземпляре указывается ссылка на класс
сразу же ответ
имя_класса$номер_экземпляра
так же подумал, что имя экземпляра может быть не только цифренным. Ему тоже можно имена давать
Серазу же ответ: если можно давать имена - это уже классы.
с экземплярами только арифметические действия выполнять.

Новость в том, что раньше я определение только из овальчиков (классов) составлял
а теперь еще и экземпляры, еще и не важно какие

Это пол беды, наличе класса - существование в списке файлов
наличеие двух экземпляров - существование в массиве экземпляров или где они там будут храниться.
(в фалйе или питон объекте).

Вторая половина беды - как будет выполняться данный код.

На какие типы вопросов нужно будет уметь отвечать -

1) сколько палка палка

по аналогии
на что похоже разница 3 4
ответ секунда

слово сколько пока можно опустить

соответсвенно должен быть второй вариант

2) скажи палка два раза
отвтет палка палка

то есть из ситуации в знак
и из знака в ситуацию

Еще раз по секунде
на_что_похоже 1 разница время
из ситуации в знак

Из знака в ситуацию с секундой не делал
выведи на экран через 10 секунд

назовем из ситуации в знак "прямым вопросм"
из знака в ситуацию "обратным вопросом"

в прямом вопросе хотелось бы использовать код на_что_похоже
но не все так просто
потому что при даче определения мы на палках объясняли, а сейчас на куржках спрашиваем
нужно или сразу объяснять на слове экземпляр и класс
или делать на питоне

так было со словом "разница"

в одной ситуации слово исполнялось, в другой нет
тут нужно разобраться что из реплик с разницей могло быть прямым или обратным вопросом
а что ни тем ни другим
и вспомнить вообще общий пайлайн исполнения любого предложения
это первый важный вопрос
второй - как измениться пайплайн, если слова вводить по одиночке (+ про метку времени еще не забыть)

Выполнение предлжения:
поледоватьель выполняются все слова с передачей в параметров соседей
если кода нет, то пропускаем
результаты в ответ в новые узлы

с прямым вопросом "палка палка"
в обоих палках нет кода
как же определить, что это двойка
можно заменить на класс$1 класс$2
кода в них все равно не будет.
значит нужно вызывать слово на_что_похоже
его походу надо всегда вызывать на равне с записью в граф всех слов

даже если бы мы не спрашивали, двойка это или не двойка
смысл двойки все равно должен всплывать в оперативном ответе
получается на одно и то же предложение возможно несколько ответов
шикарно, зафиксировать, придется выбирать

если добавить слово "сколько" так еще и разные части предложения должны выдавать разные ответы
но о частичных ответах как и о параллельном выполнении слов пока не думаем
Например
предложение "сколько палка палка всего"

сколько палка
палка палка
палка всего

каждый из этих кусков можно пропустить через сравнение с частью графа

обратный вопрос из знака в ситуацию
вопрос: два палка
ответ: палка палка

с точки зрения экземпляров в ответах могут как говориться уже упомянутые экземпляры, так и новые сгенерированные
если в графе достаточно экземлпляров, можно старые озвучить
которые использовались еще при прямом вопросе

тут в принципе логично
попадая в код слова два с передачей соседа
генерируется новый граф с необходимым количеством экземпляров и возвращается



использую монгоДБ
другие бд не знаю
монго, возможно, самая распространенная




ЗАДАЧИ

-3. Проверка старых диалогов.
    До двойки вообще нет классовости.
    Поэтому можно сначала двойку, а потом на новой архитектуре старые диалоги.

-2. Место в пайплайне сравнения куска графа.
    Является ли это функцией, которую нужно делать на постоянке не один раз в пайплайне одного предложения.
    В таком случае, слово "на что похоже" можно явно не писать.
    Вызываем ли мы эту операцию только принудительно.
    Хотел в каждом слове/строчке вызывать?


-1. Классы не только в предметной области, но и в коде.
    Класс _Class, _Object
    Занести в графу объяснения принятых решений.
    При попытке добавить деление на экземпляры и класы для всех понятий,
    пришлось изменять ранее написанный код.
    Добавлял сивол $ после каждого слова с меткой времени.
    Чтобы добавлять новые свойтсва и не не менять ранее написанное - пробую на ООП.

0. Избавиться от предыдущих наработок с $
    Время печати, порядок в предложении вынести в объект.

1. Изменить формат храненния графа.
    Каждый элемент это экземпляр какого-то класса.
    Названия классов совпадают с файлами в которых они описаны.
    В графе хранится ссылка на класс.

2. Решение задачи поиска подгрфа в графе.
    Зоздание тестового фрактального графа (звездочка).
    Соединю 4 звездочки в одну большую.
    На запрос сколько звездочек - ответ должен быть 4.
    прошу заметить, что не 5, хотя вместе они образуют звезду
    потому что слово вместе - должно образовывать отдельный график - он и есть пятый.
    вопрос на счет 5 подграфа, считаю еще открытым.

3. Предметная область палка палка

    вопрос: сохрани_определение два любой_класс$любая_цифра два тотже_класс$кроме_упомянутой_цифры
    ответ: 
    вопрос: палка$1 палка$2
    ответ: два
    вопрос: два палка
    ответ: палка$3 палка$4

    только определение двойки сразу в коде нужно, а то заколебусь

    постепенно проработанность мира в графе будем как ввысь так и вниз расширать
    то что двойка есть первородное определение, а будет второродным как раз расширение вниз


3.5 Операции перевода картины из мира в граф, из графа в мир и сравнение мира с гафом

    При чтении предложения мы переводим картину мира в граф.
    При формулировании ответа мы преводим виденье из графа в мир.
    Полученное новое представление из мира и старое запомненное представление можно сравнивать, т к оба являются графами.

    получается над словом два должна быть операция сравнения (от среды к знаку). палка палка => два
    и чтения из знака в среду (в чтении тоже сравнение). Два палка => палка палка
    у каждго класса или экземпляра должны быть эти методы. Реализуется в слове (функции) "на_что_похоже".

4. монгоДБ
    Сейчас предпологается, что экземпляры хранятся в списке в файле класса
    Написать классы и методы для работы с бд, чтоб бд можно было поменять на другую.


5. Изменение формата храненения графа.
    Вместо файлов со словами создаются файлы с классами.
    Имя файла класса совпадает имененм класса и внутри дублируется на всякий пожарный.
        Можно было сделать один файл, имитирующий БД, прописать операции для него, для быстрой замены.
        Но я так делать не буду, т к этот файл всегда придется держать только в одном режим работы
        (только запись или только чтение). Одновременно у меня по моему не получалось.
        Расширения позволяют смотреть большие json, но все равно, думаю, в большом файле будет не удобно работать.
    Храним определение.
    В списке хранятся объекты со своими полями.
        id-счетчик, Время добавления, номер в предложении

    Так же есть файл для отображения связей и элементов.
    В нем хранятся только объекты. Классы не хранятся.
    У объектов хранятся id-счетчик и название класса.


Для описания определения цифр нужны классы. Для описания классов нужно понятие модель.
Модель - группа знаков.
Нужны операции сравненния кусак графа с куском графа.
Модель - это кусок графа, который мы сравниваем с другим куском если хотим понять подходит ли второй кусок под модель.

Даже если классы пытьтся записать через второродное определение, и модель второродное, то время у знаков-объектов все равно обязательное поле.

Если все это обучать на нейросетках, то придется сначала объяснить понятия знак, модель, класс. А потом объяснять
программу слова "почему", которая бы оперировала знаками, моделями и классами.

Доделываем классы железно, посмотрим, какие сложности возникунт при понятии алгоритма.



еще раз общий пайплайн
использовать для поиска ошибок
потом актуализировать


предложение напечаталось в консоль
к кажому слову добавилась строка через долар со временем печати и порядком в предложении
выполняются поочередно все слова с параметрами в виде соседей
    ищется код слова
    в субпроцессе выполняется с переданными параметрами
        ЧИСТИМ ОТ ДОЛОРА САМО СЛОВО
        ЧИСТИМ ПАРАМЕТРЫ
        косяк - пораметры не именованные (важен только порядок)
        промежуточные вычисления для других слов записываются в json файл
полученные вычисления в виде нод записываются в классы и связи (граф)
граф перерисовывается
    БЕРЕМ НЕЧИЩЕННОЕ НАЗВАНИЕ
все слова из предложения проверяются на новизну
    косяк - граф не перерисовывается


Новый пайлайн

Вернуть экземпляры и классы входной стрки
    Проверка на пустоту входной строки, удаление пунктуации
    создание списка строк слов
    создание воходных списков экземпляров и классов
    Пополнение локальных списков экземпляров и классов

выполнение слов, если есть код
    создание новых классов
        проверка на существование файла
и сравнение с частью графа, если есть совпадение


инициализация
    создание и пополнение списков
    + список всех локальных классов
    + список всех локальных объектов
    + список классов текущего предложения
    + список объектов текущего предложения
    - список связей между объектами
выполнение
    поиск кода в лок. и глоб.
    в цикле по предложению
        выполнение слов
        дозапись ответов
            запись в списки локальных классов, объектов
            запись в список связей
    сравнение с частью графа
отрисовка
    перерисовка локального
        + цикл по списку локальных объектов
            запись всех элементов в xdot файл
        - цикл по списку связей
            нет еще ни обной связи
    перерисовка глобального
        уточню позже


что делать дальше описано в функции run_nodes
здесть сотри


(починить слово "сохрани_определение")
вопрос: сохрани_определение два two.py
ответ: 
(добавить слово два в локальный граф)
вопрос: палка палка
(на что похоже работает по связям)
     палка
      / \    два
     /   \
палка$1 палка$2

        два
        / \
       /   \
единица$1 единица$2
как здесь увидеть двойку??*??
не смотри на граф двойки, его нет, определение первородное (а может зрая первородное?)
ответ: два
вопрос: два палка
ответ: палка$3 палка$4

----------

Чтобы ответить на вопрос "на_что_похоже",
нужно, чтобы было что с чем сравнивать.
То есть должен быть граф двух экземпляров с связями с классом.
Причем информация о различии между объектами и классами как-то будет показана в графе ?
или они не отличимы.
По идее, все детали должны храниться в коде каждой ноды.
А тут мы выносим некоторые свойства для отрисовки.
В частоности классовость - объектонсть.
Так вот должны быть два графа -
класс и два объекта преметной области и граф определения двойки.
Если не делать граф двойки и оставить ее первородной, то никаких грфовых операций не требуется.
Она в таком случае работает как датчик.
Получается, после дачи ответа на вопрос граф будет таким:
единица$1 единица$2
      \    /
       \  /
        два
        /|\
       / | \
    ---  |  \
   /     |   \
  /   палка   \
 /     / \     \
/     /   \     \
палка$1 --- палка$2

Граф двойки должен быть таким универсальным, чтобы в него все это проходило.
Это уже не однократно писалось.
Должны ли протягиваться связи от двойки ко всему?
от палки1 к палке классу - связь при создании списка объектов.
между палками т к в оддном предложении, а связи мне нужны именно для закономерностей
внутри предложения, чтобы не выносить их в ноду.
от всех палок к двойке после "на_что_похоже".
Если палок будет больше связи к тройке будут?
Ответ - не обязатьельно, т к они могут вводится маленькими пачками, по одиночке
и не пройти через "на_что_похоже".

осталось сделать себе тренажер на "на_что_похоже".
рекурсивный граф звездочку.

---------------------------------------


1) возврат, принятие и сохранение новых нод, после выполнения кода других нод.
вернуть фиктивные ноды и попытатться их принять.

2) контекст. Если спросить "на что похоже" эти два объекта, то будут созданны новые
два объекта.
если повторить их имя, то будут организованы новые связи

3) косяк если ввести
1 1 1
1 1 1
не протянутся связи на класс

4) скорей всего придется вызвать слово "на что похоже" как функцию и передать ей в параметры предложение.
Протестировать рекурсивный вызов run_node.

выбираем, какое слов будем сравнивать
по очереди придется и в пределе их все не сравнить, придется выбирать
берем каждое слово из обределения сравниваемого слова,
подставляем его в первый элемент графа пердложения
если фильтр пройден, возвращается в общую структуру true
если все true из определения выполнены,
можно вернуть как результат "на что похоже" слово, у которого все true
и/или кусок графа, который совпал

"на что похоже" перебирает большой пулл слов
требуестя еще запро "похоже на два"?

можно искать одним шаблоном по всему графу и вернуть место в графе
можно определенное место подставлять во множество шаблонов

какую-то функцию или класс придется придумать ко всем этим шаблонам

передача параметра в функцию шаблонного поиска должна быть или слово или кусок графа

худший вариант сравнения всего локального графа, со всеми словами

надо сравнить граф, в котором несколько двоек, а потом решить,
 что возвращать: два, двойки, куски графа или еще что нибудь ...

все комбинации придется попробовать
ответ зависит от вопроса
придется вопрос уточнять

пишу функцию, где все на питоне, потом, часть кода на слова буду переводить

--------------------------------


запись первородных определений пока пропущу, руками файл создам если что
второродные сначала в поле класса записываются, потом в файл


секунда - 1 еденица время

бегу по вершинам графа
подходит ли вершниа под 1
да
    +
нет
    -

рано ли кол-во плюсов длинне определения


----------------

подходит ли вершниа под 1

нужно расшифровать
если первородная их леко сравнить
если они обе втрорроднвые

человек может в люом слове увидеть часть абстракции другого слова
а мне нужен дискретный ответ

возможна вариация промежуточного ответа, например сколько слов из определения совпадают
любые два сравниваемых слова поддаются логике

остановлюсь на дискретном пока

первородное определение всегда возвращает тру или фолсе
может внутри каждого первородного создавать метод run или compare ?

это для второродных:

елка - хвойное дерево
береза - лиственное дерево

для первородных:
походу намечается текст

два - объект объект класс, объект не_равне объект, объект класса и объект того_же класса

это совокупность условий

можно в определении включать не только факт наличия ноы, но и связи между ними
по сути наличие в одном предложении уже связи

кесли так, как то бы так Написать

два - _Object#1 _Class _Object#2

только #1 #2 

про елку и березу
классы сравнивать я умею, а тут надо сравнивать объекты, 
у них есть номер в списке класса
получается я должен реализовать функции сравнени в обоих этих классах
+ перекрестие объект - клаас, класс класс, объет объект
не переопреление сравнения, т к оно модет пригодиться
и так же перекрестие для первородного и второродного
питон питон, второродный второродный, питон второродный
флаг первородности хранить в поле класса

def compare(self, node_1, node_2):
    if объект
        if первородного класса
        if второго класса
    if класс
        if первородного 
        if второго 

у первородных нет степени сравнения

сравниваемая_нода vs _Object_1

вместо Object_1 можно "кодовое_имия_1" ввести

я по сути сравниваю два первородных и хочу получить True

---

можно еще так
два -  любой объект и другой объект одного класса

------

заколебался
останавливаюсть на варианте

два - _Object_1 _Class _Object_2

есть еще такой вариант
два - _Object_1 _Class. _Object_2 _Class.

готовлю инфраструктуру

сохрани_определение два _Object_1 _Class _Object_2

--------
26 08 2023

написал питон слова сохрани_определение

допустим 
Ввод: сохрани_определение два объект класс объект

Принятое решение:
не использую латинские буквы в словах, т к они могут намекнуть, на то что слова служебные
по сути слова бывают только первородные и второродные
и отличаются наличием питон файла, а не латинскими или русскими букавами

После сохранения определения
пишется предложение
Ввод: палка палка

в майне после функции run_nodes берем получившийся граф
    сейчас этот граф представлен выводм из новых слов,
    которые тут же оборачиваются в новые ноды
    т к плака палка не содержит кода, то новые слова не вернутся
    можно оперировать только input_objects, input_classes
    в которых содержатся два объекта и класс

можно кстати завести на уровне ООП класс граф и хранить в нем куски графа
производить операции над этими кусками типа сравнения

другая функция compare, определяет схожесть определений
    пробегаем по всем локальным файлам-классам и смотрим в них
    второродное определение
    должно выделиться только слово два
    в цикле пробегаемся по его словам из определения
    сравниваем 

    тут и пригодится процедура сравнения
    по началу можно просто по наличию всех слов критерий посторить

слово палка передается в слово объект
внутри слова смотрим все предложение как граф и если существует экземпляр класса _Object, то возвращается true


    хочется выхвать функцию run_nodes, но она ничего не вернет
    т к только в составе предложения может генерировать ответы от каждого слова
    и слова соседи выступают параметрами

    если бы я человеку объяснял, то спросил бы
    похоже ли предложение палка палка на определение слова два
    тут и информация что пхожа ли, у нас безусловное сравнение происходит
    и палка палка как контекст, что тоже безусловно у нас
    взять двойки и ее поределение
    по сути, в этом предложении целая программа, которую я сейчас жестко кодирую
    Ладно, я уже условился, что этот сценарий жестко будет выполняться при каждом предложении

    если вызвать run_nodes со словами "является палка _Object",
    то сгенерируется слово true, а я не хотел, чтобы это вываливалось в граф
    значит run_nodes однозначное нет, ну или позже взгляд на нее нужно пересмотреть
    на применение во внутренних рассуждениях или запретить подобное

    Черты очень похожи
    слово объект второродное
    а я уже забыл как второродные слова выполнябтся)

    Все второродные определения выполняютмя в  run_nodes
    Может жестко закгдировать пока в функции compare все на питоне, а потом по файликам растащить?
    Есть вариант compare на примере определения секунды писать
    ввод: 1 разница время
    вывод: секунда
    тут в функции compare происходит сравнение
    действительно ли "1" соответсвует "1"
    "разница" соответсвует "разница"
    все просто, когда сравнивается само с собой
    что будет если "1" соответсвует "еденица"
    тут граф нода к ноде
    могут быть и более сложные сравнения
    например что "собака" соответсвует "животное"
    всю глубину рекурсии в ответ не даем, человек тоже себя ограничивает в рассуждениях
    но если надо, дальше по цепоче идет животнео -> позвоночное -> имеет массу  и т д
    можно и разветвление в рассужениях сравнения сделать ...

    получается должен быть какой-то жесткий код, который бы не был run_nodes
    хранился внутри слова каждого и возвращал true или false

    как бы ты закодировал всех животных?
    записал всех собак, кошек ... в слове живоное и сравнивал бы со всеми
    идея был в  том, что они хранятся в графе и можно было бы по связям грфа определять принадлежность
    от собаки к живоному связь, значит возвращается true
    даже если связь через одно звено, правда можно через кошку прийти к животному и то что они едят корм

    прямой связи по графу от палок к двойке нет, если будет выдан ответ два, то ее может быть и можно провести

    Написать в определении двойки названия классов тоже не вариант
    Палки с классом мы сравнивим
    а собаку с живонтным, они разные классы, но одно в другое входит
    походу выделяются два сценария, первый - совпадение в лоб
    второй что подходит к определению дальше по иерархии

    может тогда хотя бы первый вариант реализовать

    если с секундой, то сравнение тоже один к одному идет ноды с нодой

    получатеся _Object имя класса оно должно быть графе оформлено

    "разница" равна "разница" - тру
    "плака" равна "_Object" - тру
    "собака" равна "живтоное" - тру

Предлагаю запилить все три функции
- сравнение по имени
- сравнение по типу класса
- сравнение по вложенности иерархии (позже сделаю и подумаю еще)

для секунды нужен 1 тип по имени, но там еще связи учитывались

"палка" это слово, "объект" это тоже слово

отличе в имени функции используемой для сравнения

compare_by_type("палка", "объект")
должна заходить в поля объекта и смотреть тип класса

а если так
compare_by_type("кошка", "собака")

они оба объектами могут быть

если сделать такую функцию 
is_object("палка") -> true
тогда я жестко кодирую определение двойки

по идее у меня все карты на руках и надо пытаться второродное определение двойки сделать


В определении по любому придется указать смысл экземплярности
раз у меня нет слов второродных, которыми я мог бы это объяснить
значит первородными укажу
Я всю структуру программы переделал, чтобы была возможность первороным способом
указывать экземплярность, значит ей и буду пользоваться

------

03 09 2023

цикл по локальным словам, которые содержат определение
в данном случе одно - два
можно еще секунду добавтть для теста

пропущу этот этап сразу буду с двойкой работать


рисовалку к слову переделать придется
отказаться от xdot
т к две ноды с одинаковым именем не допустимы
а захочется посмотреть на граф без метаинформации


цикл по словам из предложения
классы и объекты должны быть в общем списке, то есть список нод

    вложеный цикл по словам поределения двойки

        нода_предложения == ноде_определения
            да - запись в результат
            
проверка суммы результата
сумма должна быть равна кол-ву слов в двойке
выше может быть еще цикл по всем определениям которые знает

подробнее строку
нода_предложения == ноде_определения

напрямую обращаться в майне нельзя к типу объекта, 
так мы захардкодим определение двойки
прятать сравнение типов в опратор == тоже нельзя
получим хардкод только в операторе

значит придется пользоваться механизмом run_node
не получу ли я в таком случае накладывания совойства объектонсти на палку
или палочности на объект
ведь run_node так задумывался
не забываем, что нет деления на вопросы и ответы
есть создание картины сцены мира (локальной)
хотя в сравнении с определениями мы по сути готовим ответ

По сути это мальенькое предложение:
"Слово палка объект ?"

возникла еще мысь захардкодить в двойку сразу весь алгоритм
сравнения всех типов
но т к в параметры передаются просто строки (слова)
то придется внутри делить на классы и объекты
может быть это одно из ограничений?
т к я выполняюсь на субпроцессе, то могу только строки, а не объекты передвать параметрами

допустим короткое предложение
палка объект
после помещения палки в параметр объекта мы даже не можем сказать, класс или объект он
т к это просто строка
или избавляемся от субпроцесса или ищем дугой способ

чтобы не засорять граф новыми нодами что эта палка - объект
а эта палка - класс, я не стал слова класс и объет делать нодами (хотя в идеале надо)
 а сделал их в метополе

значит или логика должна быть там, же где метополя, то есть в майне
или я учуь передавать сложный параметр в определение

возникла мысль завести класс - Defenition
Все из не известной  и не верной архитектуры ООП ? )
не хочу сейчас переписывать это, сделай уже как нибудь

это конечно хорошо, что я сделал механизм деления на классы и объекты
можно засунуть его в код питона двойки и он там будет выполняться

на графе можно даже не отображать связи класса с объектами, т к они есть всегда

классы храняться в отдельном списке

при передаче графа двойке, даже связи не важны между двумя палками
но они есть, т к идут последоватльно в предложении.
это если пытаться объяснить все одним предложением
чтобы объяснить граф, нужно несколько предложений,
особенно сложный, где несколько зависимостей нельзя выразить
в одном предложении

пофигу делаю пока так, потом надо будет походу архитектуру переделывать
проблемные места
- передача не только названия параметра в субпроцесс 
    или наоборот если хочется передать не только название, но и метаданные - значит граф составлен не верно
- класс definition, подмать какие классы могут быть еще, может быть граф или питоновская программа, первородный и втророродный, класс знак, для букв, алфавит

если передаем слово палка_объект для сравнения со словом объект и последующим
исключением из обоих списков ,если они равны друг другу
то одни слова в питоновсом списке, а другие слова в списке файлов в папке
нужно чтоб все было в едином пространстве

я сейчас пытаюсь равнить объект с полем со строкой
определения тоже классами нужно записывать ???

хочу уже сделать как-нибудь и ветку закрыть

если бы в реальности ИИагенту показали палку и дали название, то он содл бы клас под нее со всеми деталями объекта
если показать другую палку, то из класса вычтется разница между объектами и останется только общее
(операция над множествами)
в нашем случае это множество признаков , нод, графов
так уточняется класс
причем вычитание еще и не четкое, со степенью выраженности признака

заглушка для текущей ветки
в опреелении двойки пишем прямо название классов
то есть 
два - _Object _Class _Object
при операции сравнения, она кстати функцией класса core может быть
проверяем не является ли это типом, а потом уже сравниваем по названию

когда-то, кстати, я божился, что не будет разного типа нод
и вот я снова зашел сюда
как и типа связей
тоже туда зайду? )

И если в ветке не удобно работать,
то можно от ветки отпачковывать еще ветки рекурсивно, на маленькие проблемы
А так хочется работать только в мастере, чтобы видеть прогресс

у меня еще и все приводится к нижнему регистру (

к разговору об отказе от файлов ради единого пространства
в файлы информация может просто дублироваться
подумать еще после создания архитектуры с знаками
достатоно ли передачи тектстового параметра
вообще подумть над api подпрограмм

возвращаясь к истории про веточки и корректировку класса путем операций над множествами
получается не только есть операция создания определения,
но и его уточнение
это должно быть в core и отличается от обычного изменения в kb

5 11 2023
------

создал схемку общей архитектуры
ее нужно включить в документацию
продумываю общий пайплайн

1) после ввода текста, текст конвертируется в граф.
Предпологаетмся, что можно вводить несколько предолжений.
Каждое предложение это подграф.
В результате граф может получиться несвязным.

2) у каждого известного второродного слова загружаетя его определение.
1 уровень проваливания.
они в свою очередь тоже в виде графов.

3) над графами опрелеений из предложенй производится опереция объединения.
получается общий граф.

4) В общем графе ищем изоморфные графы определений, которые уже до этого знали.
Не обязательно все искать, должны быть какие-то ограничения, что именно искать.
Обязательно уметь реализовывать 3 вида сравнения вершин.
- сравнение по имени
- сравнение по типу
- сравнение со вложенным участком определения (принадлежность к части иерархии)
- где-то здесь же, должен быть механизм вывода новых определений и закономерностей, 
изменения старых определений


Декомпозиция пайплайна на подзадачи:

создать три второродных определения из цифр
одно из них определение двойки

декомпозиция закончилась )

даже если ты будешь учитывать тип ноды при сравнении
как ты будешь задавать определение с учетом типа нод, если в языке задачи опреления используются только названия
получается понятие класса ты должен собрать сам с помощь слов, а не в коде реализовать

дача определения словосочетанию
класс два - это огда есть несколько нод два, с одним именем и разным временм ввода


как бы я задавал определение класса, если бы были известны все слова, лежащие в его основе ?

класс - список нод, обладающих общими признаками.

на одном и том же множестве нод можно образовать разные множества классов
, а не только, что они в программном коде являются какими-то там экземплярами

например, есть три машины
две из них красные и три легковые

есть вариант свобоодно переводитть любую ноду в первородный вид из второродного и наоборот

еще вариант определения хранить не в словах, в а объектах

любой-объект-и-любой-объект
2-и-2
это изоморфные графы ?

еще упростим или усложним
граф 2 это граф любой-объект ?

операция сравнения вершины графа или куска с куском должно быть общая для всех
а не содержать свою реализацию для кадой вершины

или я не прав ?

1-2-3
любой-любой-любой

изоморфны ?

а 1-2-3
любой-цифра-любой

или
1-2-3
любой-букава-любой
этот не должен быть изоморфным

с точк зрения определения изоморфности все верно
но мне это результат не нужен
значит у меня не только изоморфность

в общем пайплайне не хватает сценариев если на любом из этапов встречается первородная нода

получается сравнение нод по имени допустимо, но редко
в их сравнении необходимо раскрывать графы каждого
и потом еще и свести результат к true/false

пердлагаю остановиться на определении слов "любой", "нода"

дететям, когда учат цифры
показывают и несколько экземпляров одного и того же объекта
еще и геометрические ассоциации в форамх
еще и звук

нужно ответить на вопрос - нужно ли мне деление нод на классы и объекты
на уровне кода
потом уже продумывать весь пайплайн
сейчас пока работаю с типом данных граф без классов
нужно присать систему тестов и посравнивать разные графы
в том числе первородные с второродными

задачи

1) накидать простой маин с классами консоль, граф, core со сравнением двух графов (классы оставить)
2) нужна веб рисовалка графов для отображения всех слов для изучения. входной тип данных граф
3) возможно придется посмотреть как работает джанго и развертывание на git hub и собственный хостинг
4) потренироваться с субмодулями
5) модуль для изучения одномерного пространства. За симулятор и звуки пока не берусь

Почему можно убрать классы:

понятие_1 с графом определения или перородное

понятие_2 содержит граф с элеметом понятие_1 и новой меткой времени
по сути ссылка на класс, но классом это явно не называется
оно просото было первым

т к ноды это объекты, а не слова, у них могут быть одинаковые названия

если бы были классы, когда нужно будет объединить графы, то класс использовать 

если убрать классы, то будут постоянные ссылки на исторически первые упоминания определений

если оставить - можно скопировать только классы, забыв экземпляры
классы должны новые леко создаваться из любого участка графа

например было только одно Бородинское сражение в истории, у него есть экземпляр
можно создать еще класс и общект для фантазий для параллельной реальности
не получится в таком случае  вытащить только первый класс и перенести его в другого
агента для фантазий, экземпляр тоже нужен

а если бы небыло классов, был бы оригинал и ссылка на историческое использование
для фантазий пришлось бы ссылку на оригинальную ноду давать

ладно уговорил - оставляем классы пока

определения из классов могут позволять увидеть в графах нужные определения через опреацию изоморфности

пример
квартира на вайнера, 50 - класс
и у нее есть один единственный экземпляр
второго не будет
в определении есть квартира и адрес

может ли где то пригодится этот класс без объекта
в другом городе тоже может быть такая квартира, но о городе никто не вспоминал

все эти классы выросли когда-то из ограничения, что не может быть
двух одинаковых названий в одном списке
в списке экземпляров можно
это еще для отрисовки нужно было
если будет своя отрисовка, то уже не нужно будет ?

слово "моя" и "квартира" сами посебе ничего не занчат
но "моя квартира" уже новый смысл

в пределе - класс нужно выводить как второродное понятие, а не хардкодить

стол и тубаретку можно отнести к классу поверхнсть, а можно не относить
это не значит, что если мы выделили данный класс, то тоскать его везде с собой
бонадобилось - выделили
в вот каждый из них по отдельнсти уже надо тоскать
то есть стул, стол, поврхность

ладно меня решение
классы убираем
оставлем первородне и второродные
операция классификации будет как программа второродная
ее нужно будет применять по желанию для выделения новых определений
если так, то это придется захардкодить

ветка и ветка
будет три ветки ноды в памяти в итоге
по каждой для экземпляроности и одна абстрактная выделенная

ледно снова меняю решение - классы остаются
но не надо пугаться, что они на ходу могут динамически генерироваться
классы - это и будет система хранения знаний

экземпляры тоже на ходу генерятся, для моделирования чего-то





11 11 2023
если ноды на исполение второродны все, то раскрываются их определения и идут в общий граф

если ноды первородны все, то выполняется их код, результат в виде графа
и он посутпает на вход следующей программы

если уже есть чатсть графа от второродных раскрытий, то она вся целиком попадает на вход
первородной программе. Программа решает, какие ноду ей нужны и пораждает новые при необходимости.

если после первородных программ остался результрущий граф и есть второродные определения,
то графы просто объединяются

получается, что входные и выходные параметры всегда графы и они всегда объединяются

Задачи
1) почитать про абстрактный, виртуальный метод или интерфейс, перегрузка функции по типу данных
    https://stackoverflow.com/questions/141545/how-to-overload-init-method-based-on-argument-type
    https://www.geeksforgeeks.org/python-method-overloading/
2) протестить создание объекта
    посмотреть ак он уже был сделан
3) слова через консоль преобразовать в граф
    сначала с новыми словами, потом с известными

14 01 2024

воссоздать предметную область секунды
без консоли и рисовали не получится, аоэтому придется и их починить

--------------

31 01 2024

маленькое отступление

Есть слова, которые могут влиять на очень большое количество других слов
Например слово любой, вещь, внутри и т д.
Если строить граф, то эти слова добавляют очеь мого связей.
Вопрос: так ли устроено у человека ?
Рассмотрю альтернативный подход.
Определения не подразумевают связей. 
Они накладываются друг на друга и выдают ответ, могут ли быть похожи друг на друга.
Например слово входит и вставлятся.
Представляю себе это как пространство нейронов или равномерно распределенных вершин графа в 
роли оперативной памяти,
в которое может быть помещены два любых определения для сравнения.
При этом не нужно подтягивать граф все со всеми.
Возможно я ошибаюсь.

Пример
В определении куржки нет функционала "вставить".
Кружку можно вставить любую подходящую дырку.

Мы как-то одно наложили на другое ? (объединили графы).
Или взяли вставку из слова вставить и применили к куржке.
Хотя порядок слов может быть другим.

Получается связь вставки хранилось только во слове вставить.
к куржке подтянулось динамически и потом забудется.
Это кстати идея.
По забыванию и обновлению ненужных частей определений.

Как быть со словом "любой".
У него должно быть невероятно гибкое определение
и оно одлжно постоянно добавляться и забываться в других определениях.

Вывод
Наложение двух графов или сравнение или объединение
это не означает, что нужно вносить правки в определение
Поэтому и не обрахуется граф все со всеми или когда одна вершина имеет связи со всеми.
Но при этом остается возможность соединения двух графов для генерации новых свойств.
Новые свойства могут просто не записываться или забываться.
Переформулировать в принятые решения.
По хорошему, парсинг входной строки это не не определения.
Нужно еще принять решение о фиксации определенийи и переносе в глобалный.

-------

23 02 2024

основной вопрос как будет вестисть обработка нод в функции run_node



- входным параметром функции run_nodes являются граф.
Важно подчеркнуть, что именно один граф, а не несколько.
Обычно это граф введенного предложения.

- для следующего предложения еще раз вызывается run_nodes.

- в входном графе есть 
    первородные классы (п_к), 
    первородные объекты (п_о), 
    второродные классы (в_к), 
    второродные объекты (в_о).
выполняться могут только объекты.
в том порядке, в котором протянуты связи.
Граф предложения должен представлять собой линию,
поэтому определение порядка не должно стать проблемой.
Нужный конец определяется нулевым номером слова в номерном списке слов предложения.
классы содержат ссылки на определения.
в случае первородных это код.

- выделяется функция run_node
находится в классе _Object
внутри используются:
    внутри путь к питону (берется из поля класса, которе является ссылкой на класс)
    параметры
    выходной граф (если нода пораждает другую ноду, то между ними образуется связь)
    для второродных может понадобиться рекурсия
различается реализация для первородных и второродных.
Есть мысли о переносе в файл core


- объекты первородных классов являются датчиками.
каждый новый объект это еще один датчик.
консоль - тоже датчик.
если его представить в локальном графе и выполнить, 
то он должен сформировать выходной граф.
Получается, все первородные ноды должны при необходимости иметь возможность быть вытащены в основной код.
Обоюдная зависмость (быть в графе или в основном коде) сохраняется.

- в процессе вычислений будут образовыватьсяновые ноды.
Новые ноды участвуют в расчетах, если того требуют параметры
операция объединения результатов решения моежт как требоваться,
так и не требоваться, т к связи уже протянуты к результатам решений.
Конечно можно их складывать в отдельный граф, а потом все равно объединить.
За одно написать функцию объединения.

- выходными граф_2 (другой)
далее входной и выходной объединяются

- в качестве ответа демонстриуется граф включающи и входные данные и вычисления
возможно создание функцции которая выводит в консоль только результаты вычислений
или занимается формированием ответов на вопросы

- если в результае решения появляются не связанные никак между собой
куски графов, то они выводятся несколькими строчками выходной консолью
в разных предложениях.
То есть текст.
может если выход можт быть в виде текста, то и ввод разрежить в виде текста

Нужно решить добовлять ли новую сущность - список графов (предложений).
или в одном графе могут быть не связные куски. (несвязный граф)

Остановлюсь на первом варианте пока.
В одном графе не могут быть не связные куски.

Место куда складываются введенные предложения - локальная память - 
это не граф, а чуть большее.
Входной текст и выходной дробится на предложения.
(собирается из графов и разбирается в графы).

как быть с определениями в несколько предложений ?
ответ : не может быть определение не связным. Все предложения
связываются через контекст. В предложении либо явно указываются слова, которые уже использовались. Либо придется запилит это нечто,
что будет выполнять работу контекста.

смысл ввода определения через несколько предложений был в том, чтоб
не строить гиганские предложения.
В одно предложение не уместить все опредление.
Получется нужно дополнять режим сохранения опредления.
И говорить "начинаем сохранять определеие"
куча предложений
"заканчиваем сохранять определение"
или текстом через точку.

У меня сейчас вопрос основной цикл всей программы
работает попредложенно или потектсово.

мне точно нужно сохранять определения тектсово.
определение двойки состоит из двух предложений
значит граф у меня несвязный.
значит работаем везде в текстовом режиме.
и на выходе и входе в и в run_nodes

эти два предложения, которые предназначаются для определения двойки вводятся через точку,
раз работаем тектсово.
класс консоль должна быть к этому готова.
на выходе получается все равно один граф, который может быть несвязным.
еще раз напомню, что одно определение может быть несвязным,
то есть выраженным несолькими предложениями.

console(предложения_через_точку) -> input_graph -> 
run_text(input_graph)
    run_sentece()
        run-node() -> output_graph
    merge_graph(output_graph)
merge_graph(output_graph) ->
console(output_graph)

получается нужно ввести id пердложения для каждого слова
для возможности работы попредложениям
это и может кстати выполнять работу контекста
в контексте, что то должно решать, можно использовать уже существующий объект или новый заводить
причем для этого нужна подгрузка смыслов и определений, а значит
контекст должен работать в run_text
раз уж пошла работа на уровне текстов, то run_node точно должно быть в _Object
текст  оперирует run_node
Выводную консоль нужно подготовить
прототип объединения графов подготовить

причем output_graph это не весь локальный граф

разобраться с дозаписью input_graph в local_graph

enter во входной консоли мог символизировать
ввод следующего предложения и начало расчетов.
сейчас кадый enter это расчет сразу текста
а внутри run_text все равно могу по предложениям работать
и для выхода формировать текст.
получается можно по МЖП сначал хотя бы предложения сделать
после консоли все равно связный граф получается если без точки работать

прототипапи надо помыслить
пусть без расчета и выполнения кода нод все функции run будут что-то возвращать
программирование на тестах
можно кстати тесты освоить

----------------

10 03 2024

входной текст -> список графов [graphs]
    можно используя контекст обращать внимание на остальные предложения в списке
    обработка каждого из рпедложений. Оно в совю очередь - связный граф.
    Общие результаты обработки предложений могут быть не связными. Например орпделение в нескольких предложениях.
Вывод или только новообразованные ноды или сформулированный заново ответ. Опять же список графов.
Получается и камеры и другие типы датчиков должны говорить текстами.
Если они будут большими - псеводопараллельность текстов ?

нужно всель пайплайн текстов и нескольких источников проверять на синтетических данных.

